<!DOCTYPE html>
<html>
<head>
    <title>ヘックスグリッドバトル</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {font-family: 'Arial', sans-serif;margin: 0;padding: 0;background-color: #111827;color: #f9fafb;display: flex;justify-content: center;align-items: center;min-height: 100vh;background-size: cover;background-position: center;flex-direction: column;}
        #game-container {display: flex;flex-direction: row;align-items: flex-start;padding: 1.25rem;max-width: 100%;box-sizing: border-box;}
        #board-container {display: flex;flex-direction: column;align-items: center;margin-bottom: 0.75rem;width: 100%;max-width: 600px;margin-right: 2rem;}
        .row {display: flex;justify-content: center;margin-bottom: 0.25rem;width: 100%;}
        .hex-cell {width: 56px;height: 64px;display: flex;justify-content: center;align-items: center;margin: 0 0.25rem;border-radius: 0.5rem;font-size: 0.75rem;position: relative;animation: new-ally-fade-in 0.3s ease-out forwards;}
        .hex-inner {width: 100%;height: 100%;background-color: #4b5563;border-radius: 0.5rem;display: flex;justify-content: center;align-items: center;position: absolute;top: 0;left: 0;border: 2px solid;border-color: #6b7280;}
        .slot-number {position: absolute;top: 0.15rem;left: 0.25rem;font-size: 0.5rem;color: #cbd5e0;z-index: 10;}
        #message-box {background-color: #17233c;color: #f9fafb;padding: 0.5rem;margin-bottom: 0.75rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 600px;border: 2px solid;border-color: #6b7280;}
        .message-box-clear { background-color: #ffe35a !important; color: #062b08 !important; border-color: #fbaf21 !important; }
        .message-box-gameover { background-color: #aa2ac0 !important; color: #f3ffae !important; border-color: #f398ff !important; }
        #right-container {display: flex;flex-direction: column;align-items: center;margin-left: 2rem;padding-right: 1rem;}
        #card-description {background-color: #101520;color: #f9fafb;height: 4.0rem;padding: 0.5rem;margin-bottom: 2rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        #hand-container {display: flex;justify-content: center;margin-bottom: 0.95rem;width: 100%;max-width: 600px;}
        .card {width: 64px;height: 80px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #374151;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);}
        .card.selected {background-color: #6b7280;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);}
        .card.disabled {opacity: 0.5;cursor: not-allowed;}
        #top-right-ui {display: flex;flex-direction: row;align-items: center;justify-content: center;margin-bottom: 0.75rem;width: 100%;max-width: 400px;}
        #special-hand-container {display: flex;justify-content: center;align-items: center;margin-left: 0.5rem;margin-bottom: 0.75rem;}
        .special-card {width: 64px;height: 90px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #6b46c1;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .special-card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);}
        .special-card.selected {background-color: #7763b1;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);}
        .special-card.disabled {opacity: 0.5;cursor: not-allowed;}
        #kill-count {background-color: #101520;color: #f9fafb;padding: 0.5rem;border-radius: 0.5rem;text-align: center;margin-right: 0.5rem;margin-left: 0.2rem;margin-bottom: 0.75rem;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        .hp-bar {width: 80%;height: 0.5rem;background-color: #6b7280;border-radius: 0.25rem;margin-top: 0.25rem;position: absolute;bottom: 0.25rem;left: 10%;}
        .hp-fill {height: 100%;background-color: #86ef7d;border-radius: 0.25rem;width: 100%;}
        .hp-text {position: absolute;top: -0.6rem;right: 0.04rem;font-size: 0.7rem;color: #333;z-index: 1;}
        .damage-text {font-size: 0.9rem; }
        #game-explanation { height: 5.7em; overflow-y: auto; border: 2px solid #6b7280; background-color: #201c10; color: #f9fafb; padding: 0.5rem; border-radius: 0.5rem;  white-space: pre-line; text-align: left; margin-bottom: 0.75rem; max-width: 400px; width: 100%; box-sizing: border-box;}
        @keyframes new-ally-fade-in { 0% { opacity: 0.5; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }
        .disabled-overlay { opacity: 0.5; pointer-events: none; }
        
        .hidden { display: none; }
        .modal-overlay { z-index: 40; }
        .modal-content {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            width: 90%;
            max-width: 500px;
        }

        .attack-effect {
            position: absolute;
            top: 35%;
            left: 50%;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 20;
            animation: attack-animation 0.4s ease-out forwards;
        }

        @keyframes attack-animation {
            0% { transform: translate(-50%, -50%) scale(0.5) rotate(160deg); opacity: 0.5; }
            50% { opacity: 0.9; }
            100% { transform: translate(-50%, -50%) scale(1.2) rotate(-20deg); opacity: 0; }
        }
        
        @media (max-width: 768px) and (orientation: portrait) {
            body { justify-content: flex-start; padding: 1rem 0; margin-top: 10rem; }
            #game-container { flex-direction: column; width: 100%; padding-top: 4rem; padding: 0 1rem; }
            #left-container, #right-container { display: contents; }
            #board-container, #message-box, #hand-container, #card-description, #game-explanation { width: 100%; max-width: 100%; margin: 0 0 1rem 0; }
            #card-description { height: auto; }
            #message-box { order: 1; }
            #board-container { order: 2; }
            #hand-container { order: 3; }
            #top-right-ui { order: 4; width: 100%; max-width: 100%; margin-bottom: 1rem; justify-content: center; }
            #card-description { order: 5; }
            #game-explanation { order: 6; max-height: 6em; overflow-y: auto; }
            .mt-4.flex.justify-center.items-center { margin-top: 0; }
        }

        .main-footer { width: 100%; max-width: 600px; text-align: center; color: #374151; margin-top: 40px; }
        .main-footer a { color: #d8971d; text-decoration: none; transition: color 0.2s ease-in-out; font-size: 0.9rem; }
        .main-footer a:hover { color: #8a580c; text-decoration: underline; }
        .footer-links { display: flex; flex-wrap: wrap; justify-content: center; gap: 1.25rem; margin-bottom: 0.2rem; }
        .footer-copyright { font-size: 0.8rem; color: #6b7280; }
        
        /* Ranking Modal Styles */
        #ranking-modal-content {
            max-width: 800px;
            max-height: 85vh; /* 画面の高さの85%を最大高に設定 */
            overflow-y: auto;   /* 縦方向にコンテンツがはみ出た場合のみスクロールバーを表示 */
        }
        .ranking-list { min-height: 300px; }
        .ranking-list ol { list-style-position: inside; padding-left: 0; }
        .ranking-list li { display: flex; justify-content: space-between; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
        .ranking-list li:nth-child(odd) { background-color: #374151; }
        .ranking-list .rank-name { text-align: left; }
        .ranking-list .rank-score { font-weight: bold; }
        .my-best-score { border: 2px solid #fbbf24; }
    </style>
</head>
<body class="bg-gray-900 text-gray-50">
    <div id="game-container" class="flex flex-row items-start">
        <div id="left-container">
            <div id="board-container" class="flex flex-col items-center mb-3">
                <div class="row">
                    <div class="hex-cell" data-slot-index="0"><span class="slot-number">1</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="1"><span class="slot-number">2</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="2"><span class="slot-number">3</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="3"><span class="slot-number">4</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="4"><span class="slot-number">5</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="5"><span class="slot-number">6</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="6"><span class="slot-number">7</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="7"><span class="slot-number">8</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="8"><span class="slot-number">9</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="9"><span class="slot-number">10</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="10"><span class="slot-number">11</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="11"><span class="slot-number">12</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="12"><span class="slot-number">13</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="13"><span class="slot-number">14</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="14"><span class="slot-number">15</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="15"><span class="slot-number">16</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="16"><span class="slot-number">17</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="17"><span class="slot-number">18</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="18"><span class="slot-number">19</span><div class="hex-inner"></div></div>
                </div>
            </div>
            <div id="message-box" class="mb-3 text-center"></div>
        </div>
        <div id="right-container">
            <div id="top-right-ui" class="flex flex-row justify-center mb-3">
                <div id="kill-count" class="text-center mr-2">倒した敵の数: 0/250<br>Lv: 1<br>Exp: 0/50</div>
                <div id="special-hand-container" class="flex justify-center">
                    <div class="special-card" data-special-card-index="0"></div>
                    <div class="special-card" data-special-card-index="1"></div>
                </div>
            </div>
            <div id="hand-container" class="flex justify-center mb-3">
                </div>
            <div id="card-description" class="mb-3 text-center"></div>
            <div id="game-explanation" class="mb-3 text-left overflow-y-auto"></div>
        </div>
    </div>

    <div class="flex justify-center items-center">
        <button id="reset-button" class="bg-red-900 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full mr-5">Reset</button>
        <button id="settings-button" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Setting</button>
        <div class="ml-4 flex space-x-2">
            <div id="difficulty-indicator" class="w-4 h-4 rounded-full transition-colors" title="現在の難易度"></div>
            <div id="endless-mode-indicator" class="w-4 h-4 rounded-full transition-colors" title="エンドレスモード"></div>
        </div>
        <div id="highscore-display" class="ml-4 text-lg text-yellow-400 font-bold cursor-pointer hover:text-yellow-300 transition-colors"></div>
    </div>

    <div id="settings-modal" class="hidden">
        <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 cursor-pointer modal-overlay"></div>
        <div id="modal-content" class="fixed bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-600 text-center modal-content">
            <h2 class="text-2xl font-bold mb-6">設定</h2>
            <div class="mb-5">
                <h3 class="text-lg mb-2">難易度</h3>
                <div class="flex justify-center flex-wrap gap-2">
                    <button data-difficulty="easy" class="difficulty-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">easy</button>
                    <button data-difficulty="normal" class="difficulty-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">normal</button>
                    <button data-difficulty="hard" class="difficulty-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">hard</button>
                    <button data-difficulty="nightmare" class="difficulty-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">nightmare</button>
                    <button data-difficulty="impossible" class="difficulty-button bg-gray-200 hover:bg-gray-200 text-gray-900 font-bold py-2 px-4 rounded w-28 transition-transform duration-200">impossible</button>
                </div>
            </div>
            <div class="mb-8">
                <h3 class="text-lg mb-2">エンドレスモード</h3>
                <button id="endless-mode-button" class="bg-purple-700 hover:bg-purple-800 text-white font-bold py-2 px-4 rounded transition-colors">OFF</button>
            </div>
            <div class="flex justify-center space-x-4">
                <button id="cancel-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">キャンセル</button>
                <button id="confirm-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">決定</button>
            </div>
        </div>
    </div>

    <div id="ranking-modal" class="hidden">
        <div id="ranking-modal-overlay" class="fixed inset-0 bg-black bg-opacity-75 cursor-pointer modal-overlay"></div>
        <div id="ranking-modal-content" class="fixed bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-600 text-center modal-content">
            <h2 class="text-2xl font-bold mb-4">ランキング</h2>
            
            <div class="mb-4">
                <div class="flex justify-center flex-wrap gap-2">
                    <button data-difficulty="easy" class="ranking-difficulty-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">easy</button>
                    <button data-difficulty="normal" class="ranking-difficulty-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">normal</button>
                    <button data-difficulty="hard" class="ranking-difficulty-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">hard</button>
                    <button data-difficulty="nightmare" class="ranking-difficulty-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">nightmare</button>
                    <button data-difficulty="impossible" class="ranking-difficulty-button bg-gray-200 hover:bg-gray-200 text-gray-900 font-bold py-2 px-4 rounded w-28 transition-transform duration-200">impossible</button>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-gray-900 p-4 rounded-lg">
                    <h3 class="text-xl font-semibold mb-2 text-yellow-400">Endless: OFF</h3>
                    <div id="ranking-list-off" class="ranking-list text-left"></div>
                </div>
                <div class="bg-gray-900 p-4 rounded-lg">
                    <h3 class="text-xl font-semibold mb-2 text-purple-400">Endless: ON</h3>
                    <div id="ranking-list-on" class="ranking-list text-left"></div>
                </div>
            </div>

            <div class="bg-gray-700 p-4 rounded-lg mb-4">
                <h3 class="text-lg mb-2">My Best Score</h3>
                <div id="my-best-score-off" class="text-yellow-300 text-lg font-bold mb-1">Endless OFF: 0</div>
                <div id="my-best-score-on" class="text-purple-300 text-lg font-bold">Endless ON: 0</div>
                <div class="mt-4 flex flex-col sm:flex-row justify-center items-center gap-2">
                    <input type="text" id="username-input" placeholder="ユーザー名を入力" class="bg-gray-900 text-white px-3 py-2 rounded border border-gray-600 w-full sm:w-auto">
                    <button id="register-score-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-full sm:w-auto">スコアを登録/更新</button>
                </div>
                 <p id="firebase-status" class="text-sm text-gray-400 mt-2 h-4"></p>
            </div>

            <button id="close-ranking-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">閉じる</button>
        </div>
    </div>

    <footer class="main-footer">
        <div class="footer-links">
            <a href="https://example.com/portfolio" target="_blank" rel="noopener noreferrer">作品集</a>
            <a href="https://x.com/your_x_handle" target="_blank" rel="noopener noreferrer">X</a>
            <a href="https://example.com/privacy-policy" target="_blank" rel="noopener noreferrer">プライバシーポリシー</a>
            <a href="https://example.com/contact" target="_blank" rel="noopener noreferrer">お問い合わせ</a>
        </div>
        <div class="footer-copyright">
            ©︎2025 shiumai_4. All rights reserved.
        </div>
    </footer>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration
        // IMPORTANT: This configuration is for the user's personal Firebase project.
        const firebaseConfig = {
            apiKey: "AIzaSyC-4ofIVVGDrXrD26FYC5YeEPHCU-homCg",
            authDomain: "hexgridbattle.firebaseapp.com",
            projectId: "hexgridbattle",
            storageBucket: "hexgridbattle.appspot.com",
            messagingSenderId: "391263923010",
            appId: "1:391263923010:web:772dcec1f6a44ef30c76db",
            measurementId: "G-VMLTWEVTPN"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        let currentUser = null;

        // Game Settings
        const gameSettings = {
            initialHandSize: 5,
            boardSize: 19,
            cardTypes: ['⚡️', '🗡️', '💥'],
            enemyTypes: ['🔥', '💧', '☀️', '🌱', '🪽', '👿'],
            enemyHpValues: {'🔥': 15,'💧': 8,'☀️': 15,'🌱': 20,'🪽': 40,'👿': 150},
            attackEffectImages: {
                '⚡️': 'https://github.com/shiumai-4/hexgridbattle/blob/main/thunder.PNG?raw=true',
                '🗡️': 'https://github.com/shiumai-4/hexgridbattle/blob/main/sword.PNG?raw=true',
                '💥': 'https://github.com/shiumai-4/hexgridbattle/blob/main/explosion.PNG?raw=true',
                '💀': 'https://github.com/shiumai-4/hexgridbattle/blob/main/curse.PNG?raw=true',
                '🦠': 'https://github.com/shiumai-4/hexgridbattle/blob/main/virus.PNG?raw=true',
                '🌊': 'https://github.com/shiumai-4/hexgridbattle/blob/main/thunami.PNG?raw=true'
            },
            slotCoordinates: [
                [0, 0], [1, 0], [2, 0], [0.5, 1], [1.5, 1], [2.5, 1], [3.5, 1], [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [0.5, 3], [1.5, 3], [2.5, 3], [3.5, 3], [1, 4], [2, 4], [3, 4]
            ],
            adjacentSlots: [
                [1, 3, 4], [0, 2, 4, 5], [1, 5, 6], [0, 4, 7, 8], [0, 1, 3, 5, 8, 9], [1, 2, 4, 6, 9, 10], [2, 5, 10, 11], [3, 8, 12], [3, 4, 7, 9, 12, 13], [4, 5, 8, 10, 13, 14], [5, 6, 9, 11, 14, 15], [6, 10, 15], [7, 8, 13, 16], [8, 9, 12, 14, 16, 17], [9, 10, 13, 15, 17, 18], [10, 11, 14, 18], [12, 13, 17], [13, 14, 16, 18], [14, 15, 17]
            ],
            killsPerLevel: 5,
            levelUpThreshold: 50,
            specialCardChargeThreshold: 400,
            bossThresholdIncrement: 25,
            chainDamageMultiplier: 0.8,
            splashDamageMultiplier: 2,
            experiencePerKill: 10,
            experienceChainBonus: 4,
            cardDescriptions: {
                '⚡️': '⚡️：電撃。隣接する同じ種類の敵に追加ダメージ。',
                '🗡️': '🗡️：斬撃。敵の最大HPの1/5の追加ダメージ。',
                '💥': '💥：爆発。周囲の敵の数に応じて追加ダメージ。'
            },
            baseDamage: {'⚡️': 10, '🗡️': 15, '💥': 10},
            specialCardTypes: ['💀', '🦠', '🌊'],
            specialCardDescriptions: {
                '💀': '💀：呪縛。全ての同じ種類の敵にダメージ。',
                '🦠': '🦠：感染。隣接する敵を同化させダメージ。',
                '🌊': '🌊：津波。全ての敵にダメージ。'
            },
            specialCardBaseDamage: {'💀': 20, '🦠': 2, '🌊': 10},
            difficultySettings: {
                easy: { killTarget: 100, enemySpawnRatesInitial: [0.4, 0.6, 0, 0, 0, 0], midGameRatesCount: 35, enemySpawnRatesMidGame: [0.4, 0.5, 0, 0.1, 0, 0], finalGameRatesCount: 80, enemySpawnRatesFinalGame: [0.3, 0.5, 0, 0.2, 0, 0], bossThresholdInitial: 80 },
                normal: { killTarget: 150, enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0, 0], midGameRatesCount: 35, enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0, 0], finalGameRatesCount: 100, enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0, 0], bossThresholdInitial: 50 },
                hard: { killTarget: 250, enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0, 0], midGameRatesCount: 35, enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0, 0], finalGameRatesCount: 125, enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0, 0], bossThresholdInitial: 50 },
                nightmare: { killTarget: 200, enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0, 0], midGameRatesCount: 35, enemySpawnRatesMidGame: [0.25, 0.4, 0.1, 0.2, 0.05, 0], finalGameRatesCount: 125, enemySpawnRatesFinalGame: [0.25, 0.25, 0.2, 0.2, 0.1, 0], bossThresholdInitial: 50 },
                impossible: { killTarget: 250, enemySpawnRatesInitial: [0.3, 0.5, 0.1, 0, 0.1, 0], midGameRatesCount: 35, enemySpawnRatesMidGame: [0.3, 0.4, 0.1, 0.1, 0.1, 0], finalGameRatesCount: 125, enemySpawnRatesFinalGame: [0.2, 0.2, 0.2, 0.2, 0.2, 0], bossThresholdInitial: 50 }
            }
        };

        const gameState = {
            hand: [], board: [], selectedCardIndex: null, selectedSpecialCardIndex: null, killCount: 0, gameOver: false, handSelectionEnabled: true, playerLevel: 1, playerXp: 0, playerXpTotal: 0, expForNextLevel: 0, expAdded: 0, enemySpawnRates: [], isMidGameRatesActive: false, isFinalGameRatesActive: false, forcePurpleEnemy: false, forcePurpleEnemyCount: 0, forcePurpleEnemyThreshold: 0, bossExtraHpTimes: 0, turn: 1, specialHand: [null, null], specialCardChargeCounter: 0, specialCardChargeAdd: 400, emptySlotsPreviousTurn: [], difficulty: 'normal', isEndlessMode: false, emptySlotsCurrentTurn: []
        };

        const domElements = {
            handContainer: document.getElementById('hand-container'), specialHandContainer: document.getElementById('special-hand-container'), boardContainer: document.getElementById('board-container'), messageBox: document.getElementById('message-box'), killCountDisplay: document.getElementById('kill-count'), cardDescription: document.getElementById('card-description'), gameExplanation: document.getElementById('game-explanation'), difficultyIndicator: document.getElementById('difficulty-indicator'), endlessModeIndicator: document.getElementById('endless-mode-indicator'), highscoreDisplay: document.getElementById('highscore-display'),
            rankingModal: document.getElementById('ranking-modal'),
            rankingModalOverlay: document.getElementById('ranking-modal-overlay'),
            closeRankingButton: document.getElementById('close-ranking-button'),
            rankingListOn: document.getElementById('ranking-list-on'),
            rankingListOff: document.getElementById('ranking-list-off'),
            myBestScoreOn: document.getElementById('my-best-score-on'),
            myBestScoreOff: document.getElementById('my-best-score-off'),
            rankingDifficultyButtons: document.querySelectorAll('.ranking-difficulty-button'),
            usernameInput: document.getElementById('username-input'),
            registerScoreButton: document.getElementById('register-score-button'),
            firebaseStatus: document.getElementById('firebase-status'),
        };
        
        let rankingModalDifficulty = 'normal';

        function applyDifficultySettings(difficulty) {
            const newSettings = gameSettings.difficultySettings[difficulty];
            if (newSettings) { Object.assign(gameSettings, newSettings); }
        }

        function generateExplanationText() {
            return `【ヘックスグリッド戦略ガイド】

■ 目的
次々と現れる敵を倒し、目標討伐数を目指すのが君のミッションだ！
設定で「エンドレスモード」をONにすれば、己の限界に挑むハイスコアチャレンジも可能だ。

■ 基本戦術サイクル
ゲームはシンプルな3ステップの繰り返しだ。
1. 【選択】手札のカードから、状況に最適な1枚を選ぶ。
2. 【攻撃】盤上の敵をクリックし、カードの力で攻撃！
3. 【補充】敵を倒したマスには、新たな敵が補充される。常に次の手を考えよう。

■ 通常カードの使いこなし術
カードの特性を理解し、戦況を有利に進めよう。
・⚡️ (電撃): 同じ種類の敵が隣接していると連鎖ダメージ！敵が隣接している場合は最大のチャンスだ。
・🗡️ (斬撃): 敵の最大HPに応じてダメージが増加する。体力自慢のタフな敵にこそ真価を発揮する。
・💥 (爆発): 周囲の敵に追加ダメージ！隣接した敵の数に応じて分散ダメージを与える。

■ 一発逆転のスペシャルカード
経験値を貯めるとチャージされる必殺技。使いどころが勝利の鍵だ。
・💀 (呪縛): ターゲットと同じ種類の敵すべてを攻撃。特定の敵を一掃したい時に使おう。
・🦠 (感染): 周囲の敵をターゲットと同じ種類に変化させてダメージ。意図的に電撃(⚡️)コンボの起点を作り出せる。
・🌊 (津波): 盤上のすべての敵に大ダメージ！絶対的なピンチや、最後の一押しに最適だ。

■ 敵について
敵は倒されるたびに強くなって復活する。さらに、特定の討伐数に達すると、非常に強力なボス(👿)が出現する。心して挑め！

■ 成長とゲームオーバー
・敵を倒すと経験値を獲得し、レベルアップすると君の基本攻撃力が上昇する。同時撃破ボーナスを狙おう！
・手札がすべて無くなるとゲームオーバー。一手一手を大切に。`;
        }
        
        // Highscore functions (now only use Local Storage)
        function getHighScoreKey(difficulty, isEndless) { return `hex-grid-battle-highscore-${difficulty}-${isEndless ? 'on' : 'off'}`; }
        function saveHighScore(score) { const key = getHighScoreKey(gameState.difficulty, gameState.isEndlessMode); const currentHighScore = parseInt(localStorage.getItem(key) || '0'); if (score > currentHighScore) { localStorage.setItem(key, score); updateHighScoreUI(); } }
        function loadHighScore() { const key = getHighScoreKey(gameState.difficulty, gameState.isEndlessMode); return parseInt(localStorage.getItem(key) || '0'); }
        function updateHighScoreUI() { const highScore = loadHighScore(); domElements.highscoreDisplay.textContent = `HighScore: ${highScore}`; }

        function updateStatusIndicators() {
            domElements.difficultyIndicator.className = 'w-4 h-4 rounded-full transition-colors';
            domElements.endlessModeIndicator.className = 'w-4 h-4 rounded-full transition-colors';
            switch (gameState.difficulty) {
                case 'easy': domElements.difficultyIndicator.classList.add('bg-blue-600'); break;
                case 'normal': domElements.difficultyIndicator.classList.add('bg-yellow-500'); break;
                case 'hard': domElements.difficultyIndicator.classList.add('bg-red-600'); break;
                case 'nightmare': domElements.difficultyIndicator.classList.add('bg-purple-600'); break;
                case 'impossible': domElements.difficultyIndicator.classList.add('bg-gray-200'); break;
            }
            if (gameState.isEndlessMode) { domElements.endlessModeIndicator.classList.add('bg-purple-600'); } else { domElements.endlessModeIndicator.classList.add('bg-purple-300'); }
        }

        function showAttackEffect(slotIndex, cardType) {
            const imageUrl = gameSettings.attackEffectImages[cardType];
            if (!imageUrl) return;
            const cellElement = document.querySelector(`.hex-cell[data-slot-index="${slotIndex}"]`);
            if (!cellElement) return;
            const effectImage = document.createElement('img');
            effectImage.src = imageUrl;
            effectImage.className = 'attack-effect';
            cellElement.appendChild(effectImage);
            setTimeout(() => { if (cellElement.contains(effectImage)) { cellElement.removeChild(effectImage); } }, 400);
        }

        function preloadAttackImages() {
            const imageUrls = Object.values(gameSettings.attackEffectImages);
            imageUrls.forEach(url => { const img = new Image(); img.src = url; });
        }

        function initializeGame() {
            preloadAttackImages();
            applyDifficultySettings(gameState.difficulty);
            if (gameState.isEndlessMode) { gameSettings.killTarget = Infinity; }
            Object.assign(gameState, { hand: [], board: [], selectedCardIndex: null, selectedSpecialCardIndex: null, killCount: 0, gameOver: false, handSelectionEnabled: true, playerLevel: 1, playerXp: 0, playerXpTotal: 0, expForNextLevel: 0, expAdded: 0, specialCardChargeCounter: 0, specialCardChargeAdd: 400, emptySlotsPreviousTurn: [], emptySlotsCurrentTurn: [], specialHand: [null, null], enemySpawnRates: [...gameSettings.enemySpawnRatesInitial], forcePurpleEnemyCount: gameSettings.bossThresholdInitial, forcePurpleEnemyThreshold: gameSettings.bossThresholdIncrement, isMidGameRatesActive: false, isFinalGameRatesActive: false, forcePurpleEnemy: false, bossExtraHpTimes: 0 });
            domElements.gameExplanation.textContent = generateExplanationText();
            updateMessageBoxUI('ゲーム開始');
            updateKillCountUI();
            updateStatusIndicators();
            updateHighScoreUI();
            for (let i = 0; i < gameSettings.initialHandSize; i++) { drawCard(); }
            gameState.board = Array(gameSettings.boardSize).fill(null);
            for (let i = 0; i < gameSettings.boardSize; i++) { spawnEnemy(i); }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            domElements.boardSlots = document.querySelectorAll('#board-container .hex-cell');
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            if (!domElements.handContainer.listener) { domElements.handContainer.addEventListener('click', (domElements.handContainer.listener = handleHandClick)); }
            if (!domElements.boardContainer.listener) { domElements.boardContainer.addEventListener('click', (domElements.boardContainer.listener = handleBoardClick)); }
            if (!domElements.specialHandContainer.listener) { domElements.specialHandContainer.addEventListener('click', (domElements.specialHandContainer.listener = handleSpecialHandClick)); }
            replenishEnemies();
            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            updateMessageBoxUI('手札を選択してください');
            recordCurrentEmptySlots();
        }

        function replenishEnemies() {
            gameState.emptySlotsPreviousTurn.forEach(emptySlotIndex => { if (!gameState.board[emptySlotIndex] || gameState.board[emptySlotIndex].empty) { spawnEnemy(emptySlotIndex); } });
            gameState.emptySlotsPreviousTurn = [];
            updateBoardUI();
        }

        function recordCurrentEmptySlots() { gameState.emptySlotsCurrentTurn = gameState.board.reduce((acc, cell, index) => { if (!cell || cell.empty) { acc.push(index); } return acc; }, []); }
        function drawCard() { if (gameState.hand.length < 5) { const randomCardType = gameSettings.cardTypes[Math.floor(Math.random() * gameSettings.cardTypes.length)]; gameState.hand.push(randomCardType); } }
        function spawnEnemy(slotIndex) { const enemyType = generateEnemyType(); gameState.bossExtraHpTimes = (enemyType === '👿') ? 2 : 0; const newHp = gameSettings.enemyHpValues[enemyType] + Math.floor(gameState.killCount / 5) * 3 + Math.floor(gameState.killCount / 10) + gameState.playerLevel * gameState.bossExtraHpTimes; gameState.board[slotIndex] = { enemy: { type: enemyType, hp: newHp, maxHp: newHp }, empty: false }; }
        function handleHandClick(event) { if (!gameState.handSelectionEnabled || gameState.gameOver) return; const cardElement = event.target.closest('.card'); if (cardElement) { const cardIndex = parseInt(cardElement.dataset.cardIndex); if (gameState.hand[cardIndex] !== undefined) { selectCard(cardIndex); } } }
        function handleBoardClick(event) { if (gameState.selectedCardIndex === null && gameState.selectedSpecialCardIndex === null || gameState.gameOver) return; const hexCell = event.target.closest('.hex-cell'); if (hexCell) { const slotIndex = parseInt(hexCell.dataset.slotIndex); attack(slotIndex); } }
        function handleSpecialHandClick(event) { if (gameState.gameOver) return; const cardElement = event.target.closest('.special-card'); if (cardElement) { const cardIndex = parseInt(cardElement.dataset.specialCardIndex); if (gameState.specialHand[cardIndex]) { selectCard(cardIndex + 5); } } }

        function updateHandUI() {
            domElements.handContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.cardIndex = i;
                if (gameState.hand[i] !== undefined) { 
                    card.textContent = gameState.hand[i];
                    if (gameState.handSelectionEnabled) { card.classList.add('cursor-pointer'); card.classList.remove('opacity-50', 'cursor-not-allowed'); } else { card.classList.add('opacity-50', 'cursor-not-allowed', 'cursor-default'); }
                    if (gameState.selectedCardIndex === i) { card.classList.add('selected'); }
                } else { card.classList.add('opacity-30', 'cursor-not-allowed'); card.textContent = ''; }
                domElements.handContainer.appendChild(card);
            }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            updateCardDescriptionUI();
        }

        function updateSpecialHandUI() {
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            for (let i = 0; i < 2; i++) {
                const card = domElements.specialHandSlots[i];
                card.classList.remove('selected', 'opacity-30', 'cursor-not-allowed', 'cursor-pointer'); 
                if (gameState.specialHand[i]) { card.textContent = gameState.specialHand[i]; card.classList.add('cursor-pointer'); } else { card.classList.add('opacity-30', 'cursor-not-allowed'); card.textContent = ''; }
                if (gameState.selectedSpecialCardIndex === i) { card.classList.add('selected'); }
            }
            updateCardDescriptionUI();
        }

        function updateBoardUI() {
            domElements.boardContainer.querySelectorAll('.hex-cell').forEach((cell) => {
                const slotIndex = parseInt(cell.dataset.slotIndex);
                const cellInner = cell.querySelector('.hex-inner');
                cellInner.className = 'hex-inner';
                if (gameState.board[slotIndex] && !gameState.board[slotIndex].empty) {
                    const enemy = gameState.board[slotIndex].enemy;
                    cellInner.textContent = enemy.type;
                    cellInner.innerHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%; background-color: ${enemy.hp <= enemy.maxHp / 2 ? 'red' : enemy.hp <= enemy.maxHp * 0.75 ? 'yellow' : 'green'};"></div><span class="hp-text">${enemy.hp}</span></div>`;
                    const colorClass = { '🔥': 'bg-red-500', '💧': 'bg-blue-500', '☀️': 'bg-yellow-500', '🌱': 'bg-green-500', '🪽': 'bg-gray-700', '👿': 'bg-purple-500' }[enemy.type];
                    if (colorClass) cellInner.classList.add(colorClass);
                } else { cellInner.classList.add('bg-gray-400'); cellInner.textContent = 'empty'; }
            });
        }

        function updateKillCountUI() {
            const expBarWidth = (gameState.expForNextLevel / gameSettings.levelUpThreshold) * 100;
            const expBar = `<div style="width: 100%; background-color: #4b5563; border-radius: 0.25rem; margin-top: 0.25rem; position: relative; height: 0.6rem;"><div style="width: ${expBarWidth}%; background-color: #86ef7d; height: 100%; border-radius: 0.25rem;"></div></div>`;
            const targetDisplay = gameSettings.killTarget === Infinity ? '∞' : gameSettings.killTarget;
            domElements.killCountDisplay.innerHTML = `倒した敵の数: ${gameState.killCount}/${targetDisplay}<br>Lv: ${gameState.playerLevel}<br>Exp: ${gameState.playerXpTotal}  (+${gameState.expAdded})${expBar}`;
        }

        function updateCardDescriptionUI() {
            let description = '選択したカードの効果を表示';
            let damageText = '';
            if (gameState.selectedCardIndex !== null) {
                const cardType = gameState.hand[gameState.selectedCardIndex];
                description = gameSettings.cardDescriptions[cardType] || description;
                const baseDamage = gameSettings.baseDamage[cardType] || 0;
                damageText = `<span class="damage-text">基本ダメージ: ${baseDamage + gameState.playerLevel}</span>`;
            } else if (gameState.selectedSpecialCardIndex !== null) {
                const cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                description = gameSettings.specialCardDescriptions[cardType] || description;
                const baseDamage = gameSettings.specialCardBaseDamage[cardType] || 0;
                damageText = `<span class="damage-text">基本ダメージ: ${baseDamage + gameState.playerLevel}</span>`;
            }
            domElements.cardDescription.innerHTML = `${description}<br>${damageText}`;
        }

        function updateMessageBoxUI(message) { domElements.messageBox.textContent = message; }
        function selectCard(index) {
            if (gameState.gameOver || !gameState.handSelectionEnabled) return;
            if (index >= 0 && index < 5) { gameState.selectedCardIndex = index; gameState.selectedSpecialCardIndex = null; } else { gameState.selectedSpecialCardIndex = index - 5; gameState.selectedCardIndex = null; }
            updateHandUI(); updateSpecialHandUI(); updateCardDescriptionUI(); updateMessageBoxUI('攻撃するマスを選択してください');
        }

        function attack(slotIndex) {
            if (gameState.gameOver) return;
            let cardType = null, baseDamage = 0, selectedIndex = null;
            if (gameState.selectedCardIndex !== null) { cardType = gameState.hand[gameState.selectedCardIndex]; baseDamage = gameSettings.baseDamage[cardType] + gameState.playerLevel; selectedIndex = gameState.selectedCardIndex; } else if (gameState.selectedSpecialCardIndex !== null) { cardType = gameState.specialHand[gameState.selectedSpecialCardIndex]; baseDamage = gameSettings.specialCardBaseDamage[cardType] + gameState.playerLevel; selectedIndex = gameState.selectedSpecialCardIndex; } else { updateMessageBoxUI('手札を先に選んでください'); return; }
            if (!gameState.board[slotIndex] || gameState.board[slotIndex].empty) { updateMessageBoxUI('空のマスには攻撃できません'); return; }

            let enemiesKilled = 0;
            const attackedSlot = gameState.board[slotIndex];
            
            switch (cardType) {
                case '⚡️': {
                    const queue = [slotIndex];
                    const damagedSlots = new Set();
                    while (queue.length > 0) {
                        const currentSlotIndex = queue.shift();
                        if (damagedSlots.has(currentSlotIndex)) continue;
                        damagedSlots.add(currentSlotIndex);
                        const damage = currentSlotIndex === slotIndex ? baseDamage : Math.floor(baseDamage * gameSettings.chainDamageMultiplier);
                        const currentCell = gameState.board[currentSlotIndex];
                        if (currentCell && !currentCell.empty) {
                            currentCell.enemy.hp -= damage;
                            showAttackEffect(currentSlotIndex, cardType);
                            if (currentCell.enemy.hp <= 0) { currentCell.empty = true; enemiesKilled++; handleBossSpawn(); }
                            const adjacentSlots = gameSettings.adjacentSlots[currentSlotIndex] || [];
                            for (const adjacentSlotIndex of adjacentSlots) { if (gameState.board[adjacentSlotIndex] && !gameState.board[adjacentSlotIndex].empty && gameState.board[adjacentSlotIndex].enemy.type === attackedSlot.enemy.type) { queue.push(adjacentSlotIndex); } }
                        }
                    }
                    break;
                }
                case '🗡️': {
                    let damage = baseDamage + Math.floor(attackedSlot.enemy.maxHp / 5);
                    attackedSlot.enemy.hp -= damage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case '💥': {
                    const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                    const adjacentEnemies = adjacentSlots.filter(index => gameState.board[index] && !gameState.board[index].empty);
                    const splashDamage = adjacentEnemies.length > 0 ? Math.floor((baseDamage * gameSettings.splashDamageMultiplier) / adjacentEnemies.length) : 0;
                    adjacentEnemies.forEach(adjacentSlotIndex => {
                        const cell = gameState.board[adjacentSlotIndex];
                        cell.enemy.hp -= splashDamage;
                        showAttackEffect(adjacentSlotIndex, cardType);
                        if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                    });
                    attackedSlot.enemy.hp -= baseDamage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case '💀': {
                    const targetEnemyType = attackedSlot.enemy.type;
                    gameState.board.forEach((cell, index) => {
                        if (cell && !cell.empty && cell.enemy.type === targetEnemyType) {
                            cell.enemy.hp -= baseDamage + Math.floor(gameState.playerLevel * 0.5);;
                            showAttackEffect(index, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    break;
                }
                case '🦠': {
                    const targetEnemyType = attackedSlot.enemy.type;
                    const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                    adjacentSlots.forEach(adjIndex => {
                        const cell = gameState.board[adjIndex];
                        if (cell && !cell.empty) {
                            cell.enemy.type = targetEnemyType;
                            cell.enemy.hp -= Math.floor(baseDamage * 0.3);
                            showAttackEffect(adjIndex, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    attackedSlot.enemy.hp -= baseDamage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case '🌊': {
                    gameState.board.forEach((cell, index) => {
                        if (cell && !cell.empty) {
                            cell.enemy.hp -= baseDamage;
                            showAttackEffect(index, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    break;
                }
            }

            updateMessageBoxUI('攻撃！');
            if (selectedIndex !== null) {
                if (gameState.selectedCardIndex !== null) { gameState.hand.splice(gameState.selectedCardIndex, 1); } else if (gameState.selectedSpecialCardIndex !== null) { gameState.specialHand[gameState.selectedSpecialCardIndex] = null; }
            }
            gameState.selectedCardIndex = null; gameState.selectedSpecialCardIndex = null; gameState.handSelectionEnabled = false;
            
            gameState.killCount += enemiesKilled;
            updateHandUI(); updateSpecialHandUI(); updateBoardUI(); handleExperience(enemiesKilled); updateKillCountUI();

            setTimeout(() => {
                const cardsToDraw = Math.min(enemiesKilled, 5 - gameState.hand.length);
                for (let i = 0; i < cardsToDraw; i++) { drawCard(); }
                recordCurrentEmptySlots();
                const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);
                if (isBoardCompletelyEmpty) { gameState.emptySlotsPreviousTurn = Array.from({ length: gameSettings.boardSize }, (_, i) => i); replenishEnemies(); gameState.emptySlotsCurrentTurn = []; } else { replenishEnemies(); gameState.emptySlotsPreviousTurn = [...gameState.emptySlotsCurrentTurn]; gameState.emptySlotsCurrentTurn = []; }
                gameState.handSelectionEnabled = true;
                
                updateHandUI(); updateSpecialHandUI(); updateBoardUI(); updateMessageBoxUI('手札を選択してください');
                if (!gameState.isEndlessMode && gameState.killCount >= gameSettings.killTarget) { gameState.gameOver = true; endGame(); } else if (gameState.hand.length === 0 && gameState.specialHand.every(card => card === null) && gameState.board.some(cell => cell && !cell.empty)) { gameState.gameOver = true; endGame(); return; }
            }, 400);
        }

        function handleBossSpawn() { if (gameState.killCount >= gameState.forcePurpleEnemyCount) { gameState.forcePurpleEnemy = true; gameState.forcePurpleEnemyCount += gameState.forcePurpleEnemyThreshold; } }
        function generateEnemyType() { if (gameState.forcePurpleEnemy) { gameState.forcePurpleEnemy = false; return '👿'; } else { let rand = Math.random(); let cumulativeProbability = 0; for (let i = 0; i < gameState.enemySpawnRates.length; i++) { cumulativeProbability += gameState.enemySpawnRates[i]; if (rand < cumulativeProbability) { return gameSettings.enemyTypes[i]; } } return gameSettings.enemyTypes[gameSettings.enemyTypes.length - 1]; } }

        function handleExperience(enemiesKilled) {
            const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);
            gameState.expAdded = isBoardCompletelyEmpty ? gameSettings.specialCardChargeThreshold : (enemiesKilled * gameSettings.experiencePerKill) + (enemiesKilled > 0 ? (enemiesKilled - 1) * gameSettings.experienceChainBonus : 0);
            gameState.playerXpTotal += gameState.expAdded;
            gameState.playerXp += gameState.expAdded;
            gameState.specialCardChargeCounter += gameState.expAdded;
            if (gameState.killCount >= gameSettings.midGameRatesCount && !gameState.isMidGameRatesActive) { gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesMidGame]; gameState.isMidGameRatesActive = true; } else if (gameState.killCount >= gameSettings.finalGameRatesCount && !gameState.isFinalGameRatesActive) { gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesFinalGame]; gameState.isFinalGameRatesActive = true; }
            while (gameState.playerXp >= gameSettings.levelUpThreshold) { gameState.playerLevel++; gameState.playerXp -= gameSettings.levelUpThreshold; }
            gameState.expForNextLevel = gameState.playerXp % gameSettings.levelUpThreshold;
            while (gameState.specialCardChargeCounter >= gameState.specialCardChargeAdd) { gameState.specialCardChargeAdd += gameSettings.specialCardChargeThreshold; addSpecialCardToHand(); updateSpecialHandUI(); }
        }

        function addSpecialCardToHand() { const emptySlotIndex = gameState.specialHand.findIndex(card => card === null); if (emptySlotIndex !== -1) { const randomCardType = gameSettings.specialCardTypes[Math.floor(Math.random() * gameSettings.specialCardTypes.length)]; gameState.specialHand[emptySlotIndex] = randomCardType; } }

        function endGame() {
            domElements.handContainer.classList.add('disabled-overlay');
            domElements.boardContainer.classList.add('disabled-overlay');
            domElements.specialHandContainer.classList.add('disabled-overlay');
            const normalCardCount = gameState.hand.length;
            const specialCardCount = gameState.specialHand.filter(card => card !== null).length;
            const score = gameState.playerXpTotal + (normalCardCount * 30) + (specialCardCount * 100);
            saveHighScore(score);
            const isClear = !gameState.isEndlessMode && gameState.killCount >= gameSettings.killTarget;
            if (isClear) { updateMessageBoxUI(`ゲームクリア！ Score: ${score}`); domElements.messageBox.classList.add('message-box-clear'); } else { updateMessageBoxUI(`ゲームオーバー Score: ${score}`); domElements.messageBox.classList.add('message-box-gameover'); }
        }
        
        function resetGame() {
            domElements.handContainer.classList.remove('disabled-overlay');
            domElements.boardContainer.classList.remove('disabled-overlay');
            domElements.specialHandContainer.classList.remove('disabled-overlay');
            domElements.messageBox.classList.remove('message-box-clear', 'message-box-gameover');
            initializeGame();
        }

        document.getElementById('reset-button').addEventListener('click', resetGame);
        
        // Settings Modal Logic
        const settingsModal = document.getElementById('settings-modal'), openSettingsButton = document.getElementById('settings-button'), cancelButton = document.getElementById('cancel-button'), confirmButton = document.getElementById('confirm-button'), modalOverlay = document.querySelector('#settings-modal .modal-overlay'), difficultyButtons = document.querySelectorAll('.difficulty-button'), endlessModeButton = document.getElementById('endless-mode-button');
        let tempDifficulty, tempIsEndlessMode;
        function updateDifficultyButtonsUI() { difficultyButtons.forEach(button => { button.classList.toggle('scale-110', button.dataset.difficulty === tempDifficulty); button.classList.toggle('opacity-75', button.dataset.difficulty !== tempDifficulty); }); }
        function updateEndlessModeButtonUI() { if (tempIsEndlessMode) { endlessModeButton.textContent = 'ON'; endlessModeButton.classList.replace('bg-purple-400', 'bg-purple-700'); } else { endlessModeButton.textContent = 'OFF'; endlessModeButton.classList.replace('bg-purple-700', 'bg-purple-400'); } }
        function openSettingsModal() { tempDifficulty = gameState.difficulty; tempIsEndlessMode = gameState.isEndlessMode; updateDifficultyButtonsUI(); updateEndlessModeButtonUI(); settingsModal.classList.remove('hidden'); }
        function closeSettingsModal() { settingsModal.classList.add('hidden'); }
        difficultyButtons.forEach(button => { button.addEventListener('click', () => { tempDifficulty = button.dataset.difficulty; updateDifficultyButtonsUI(); }); });
        endlessModeButton.addEventListener('click', () => { tempIsEndlessMode = !tempIsEndlessMode; updateEndlessModeButtonUI(); });
        openSettingsButton.addEventListener('click', openSettingsModal);
        cancelButton.addEventListener('click', closeSettingsModal);
        modalOverlay.addEventListener('click', closeSettingsModal);
        confirmButton.addEventListener('click', () => { const difficultyChanged = gameState.difficulty !== tempDifficulty; const endlessModeChanged = gameState.isEndlessMode !== tempIsEndlessMode; if (difficultyChanged || endlessModeChanged) { gameState.difficulty = tempDifficulty; gameState.isEndlessMode = tempIsEndlessMode; resetGame(); } closeSettingsModal(); });
        
        // Ranking Modal Logic
        function openRankingModal() {
            rankingModalDifficulty = gameState.difficulty;
            updateRankingDifficultyButtonsUI();
            fetchAndDisplayRankings();
            domElements.rankingModal.classList.remove('hidden');
        }

        function closeRankingModal() {
            domElements.rankingModal.classList.add('hidden');
        }

        function updateRankingDifficultyButtonsUI() {
            domElements.rankingDifficultyButtons.forEach(button => {
                button.classList.toggle('scale-110', button.dataset.difficulty === rankingModalDifficulty);
                button.classList.toggle('opacity-75', button.dataset.difficulty !== rankingModalDifficulty);
            });
        }
        
        async function fetchAndDisplayRankings() {
            if (!currentUser) {
                console.log("Cannot fetch rankings, user not authenticated.");
                return;
            }
            // Display personal bests from local storage
            const myBestOn = localStorage.getItem(getHighScoreKey(rankingModalDifficulty, true)) || 0;
            const myBestOff = localStorage.getItem(getHighScoreKey(rankingModalDifficulty, false)) || 0;
            domElements.myBestScoreOn.textContent = `Endless ON: ${myBestOn}`;
            domElements.myBestScoreOff.textContent = `Endless OFF: ${myBestOff}`;

            // Fetch from Firebase
            const rankOnId = `${rankingModalDifficulty}-on`;
            const rankOffId = `${rankingModalDifficulty}-off`;
            
            const rankOnDoc = await getDoc(doc(db, "rankings", rankOnId));
            const rankOffDoc = await getDoc(doc(db, "rankings", rankOffId));

            const rankingsOn = rankOnDoc.exists() ? rankOnDoc.data().scores : [];
            const rankingsOff = rankOffDoc.exists() ? rankOffDoc.data().scores : [];
            
            displayRankingList(domElements.rankingListOn, rankingsOn, myBestOn);
            displayRankingList(domElements.rankingListOff, rankingsOff, myBestOff);
        }

        function displayRankingList(element, rankings, myBest) {
            element.innerHTML = '';
            if (rankings.length === 0) {
                element.innerHTML = '<p class="text-gray-400">まだランキングデータがありません。</p>';
                return;
            }
            const ol = document.createElement('ol');
            rankings.forEach((entry, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="rank-name">${index + 1}. ${entry.username}</span> <span class="rank-score">${entry.score}</span>`;
                if (currentUser && entry.userId === currentUser.uid && entry.score == myBest) {
                    li.classList.add('my-best-score');
                }
                ol.appendChild(li);
            });
            element.appendChild(ol);
        }

        async function registerScore() {
            if (!currentUser) {
                domElements.firebaseStatus.textContent = '認証が完了していません。';
                return;
            }
            const username = domElements.usernameInput.value.trim();
            if (!username) {
                domElements.firebaseStatus.textContent = 'ユーザー名を入力してください。';
                return;
            }
            
            domElements.firebaseStatus.textContent = 'スコアを登録中...';
            
            const userScores = {};
            const difficulties = Object.keys(gameSettings.difficultySettings);
            const modes = [true, false]; // true for on, false for off

            for (const diff of difficulties) {
                for (const mode of modes) {
                    const key = getHighScoreKey(diff, mode);
                    const score = parseInt(localStorage.getItem(key) || '0');
                    if (score > 0) {
                        userScores[key] = score;
                    }
                }
            }
            
            try {
                // 1. Update user's personal document
                const userDocRef = doc(db, "userScores", currentUser.uid);
                await setDoc(userDocRef, { username, scores: userScores }, { merge: true });

                // 2. Update global ranking boards for each score
                for (const key in userScores) {
                    const score = userScores[key];
                    const rankId = key.replace('hex-grid-battle-highscore-', '');
                    const rankDocRef = doc(db, "rankings", rankId);
                    
                    await runTransaction(db, async (transaction) => {
                        const rankDoc = await transaction.get(rankDocRef);
                        let scores = rankDoc.exists() ? rankDoc.data().scores : [];

                        // Remove old score from the same user
                        scores = scores.filter(s => s.userId !== currentUser.uid);

                        // Add new score
                        scores.push({ userId: currentUser.uid, username, score });

                        // Sort and trim
                        scores.sort((a, b) => b.score - a.score);
                        if (scores.length > 10) {
                            scores = scores.slice(0, 10);
                        }

                        transaction.set(rankDocRef, { scores });
                    });
                }
                
                domElements.firebaseStatus.textContent = '登録が完了しました！';
                fetchAndDisplayRankings(); // Refresh the view
            } catch (error) {
                console.error("Error writing document: ", error);
                domElements.firebaseStatus.textContent = '登録に失敗しました。';
            } finally {
                setTimeout(() => { domElements.firebaseStatus.textContent = ''; }, 3000);
            }
        }
        
        async function loadUsernameFromFirebase() {
            if (!currentUser) return;
            const userDocRef = doc(db, "userScores", currentUser.uid);
            const userDoc = await getDoc(userDocRef);
            if (userDoc.exists() && userDoc.data().username) {
                domElements.usernameInput.value = userDoc.data().username;
            }
        }

        // Event Listeners for Ranking Modal
        domElements.highscoreDisplay.addEventListener('click', openRankingModal);
        domElements.rankingModalOverlay.addEventListener('click', closeRankingModal);
        domElements.closeRankingButton.addEventListener('click', closeRankingModal);
        domElements.rankingDifficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                rankingModalDifficulty = button.dataset.difficulty;
                updateRankingDifficultyButtonsUI();
                fetchAndDisplayRankings();
            });
        });
        domElements.registerScoreButton.addEventListener('click', registerScore);

        // Firebase Authentication and App Start
        function startApp() {
            let gameInitialized = false;

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // User is signed in.
                    currentUser = user;
                    console.log("Authentication successful, UID:", currentUser.uid);
                    loadUsernameFromFirebase();

                    // Initialize the game only once after the first successful auth state is confirmed.
                    if (!gameInitialized) {
                        initializeGame();
                        gameInitialized = true;
                    }
                } else {
                    // User is signed out. Attempt to sign in anonymously.
                    currentUser = null;
                    console.log("User is not authenticated, attempting to sign in anonymously.");
                    signInAnonymously(auth).catch((error) => {
                        console.error("Anonymous sign-in failed:", error);
                        // Initialize game even on auth failure, but ranking will be disabled.
                        if (!gameInitialized) {
                            initializeGame();
                            gameInitialized = true;
                        }
                    });
                }
            });
        }

        startApp();
    </script>
</body>
</html>
