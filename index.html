<!DOCTYPE html>
<html>
<head>
    <title>„Éò„ÉÉ„ÇØ„Çπ„Ç∞„É™„ÉÉ„Éâ„Éê„Éà„É´</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {font-family: 'Arial', sans-serif;margin: 0;padding: 0;background-color: #111827;color: #f9fafb;display: flex;justify-content: center;align-items: center;min-height: 100vh;background-size: cover;background-position: center;flex-direction: column;}
        #game-container {display: flex;flex-direction: row;align-items: center;padding: 1.25rem;max-width: 100%;width: 100%;box-sizing: border-box;}
        #board-container {display: flex;flex-direction: column;align-items: center;margin-bottom: 0.75rem;width: 100%;max-width: 600px;margin-right: 2rem;}
        .row {display: flex;justify-content: center;margin-bottom: 0.25rem;width: 100%;}
        .hex-cell {width: 56px;height: 64px;display: flex;justify-content: center;align-items: center;margin: 0 0.25rem;border-radius: 0.5rem;font-size: 0.75rem;position: relative;animation: new-ally-fade-in 0.3s ease-out forwards;}
        .hex-inner {width: 100%;height: 100%;background-color: #4b5563;border-radius: 0.5rem;display: flex;justify-content: center;align-items: center;position: absolute;top: 0;left: 0;border: 2px solid;border-color: #6b7280;}
        .hex-–∑–¥–æ—Ä–æ–≤ {background-color: #86ef7d;}
        .hex-–æ—Å–ª–∞–±–ª–µ–Ω {background-color: #f43f5e;}
        .enemy-–∑–¥–æ—Ä–æ–≤ {color: #ffffff;}
        .enemy-–æ—Å–ª–∞–±–ª–µ–Ω {color: #ffffff;}
        .slot-number {position: absolute;top: 0.15rem;left: 0.25rem;font-size: 0.5rem;color: #cbd5e0;z-index: 10;}
        #message-box {background-color: #17233c;color: #f9fafb;padding: 0.5rem;margin-bottom: 0.75rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 600px;border: 2px solid;border-color: #6b7280;}
        .message-box-clear { background-color: #ffe35a !important; color: #062b08 !important; border-color: #fbaf21 !important; }
        .message-box-gameover { background-color: #aa2ac0 !important; color: #f3ffae !important; border-color: #f398ff !important; }
        #right-container {display: flex;flex-direction: column;align-items: center;margin-left: 2rem;padding-right: 1rem;}
        #card-description {background-color: #101520;color: #f9fafb;height: 4.0rem;padding: 0.5rem;margin-bottom: 2rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        #hand-container {display: flex;justify-content: center;margin-bottom: 0.95rem;width: 100%;max-width: 600px;}
        .card {width: 64px;height: 80px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #374151;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.3);}
        .card.selected {background-color: #6b7280;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.4);}
        .card.disabled {opacity: 0.5;cursor: not-allowed;}
        #top-right-ui {display: flex;flex-direction: row;align-items: center;justify-content: center;margin-bottom: 0.75rem;width: 100%;max-width: 400px;}
        #special-hand-container {display: flex;justify-content: center;align-items: center;margin-left: 0.5rem;margin-bottom: 0.75rem;}
        .special-card {width: 64px;height: 90px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #6b46c1;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .special-card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);}
        .special-card.selected {background-color: #7763b1;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);}
        .special-card.disabled {opacity: 0.5;cursor: not-allowed;}
        #kill-count {background-color: #101520;color: #f9fafb;padding: 0.5rem;border-radius: 0.5rem;text-align: center;margin-right: 0.5rem;margin-left: 0.2rem;margin-bottom: 0.75rem;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        .hp-bar {width: 80%;height: 0.5rem;background-color: #6b7280;border-radius: 0.25rem;margin-top: 0.25rem;position: absolute;bottom: 0.25rem;left: 10%;}
        .hp-fill {height: 100%;background-color: #86ef7d;border-radius: 0.25rem;width: 100%;}
        .hp-text {position: absolute;top: -0.6rem;right: 0.04rem;font-size: 0.7rem;color: #333;z-index: 1;}
        .damage-text {font-size: 0.9rem; }
        #game-explanation { height: 5.7em; overflow-y: auto; border: 2px solid #6b7280; background-color: #201c10; color: #f9fafb; padding: 0.5rem; border-radius: 0.5rem;  white-space: pre-line; text-align: left; margin-bottom: 0.75rem; max-width: 400px; width: 100%; box-sizing: border-box;}
        @keyframes new-ally-fade-in { 0% { opacity: 0.5; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }
        .disabled-overlay { opacity: 0.5; pointer-events: none; }
        
        .hidden { display: none; }
        #modal-overlay { z-index: 40; }
        #modal-content {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            width: 90%;
            max-width: 500px;
        }

        /* ‚ñº‚ñº‚ñº Â§âÊõ¥ÁÆáÊâÄ ‚ñº‚ñº‚ñº */
        .attack-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 20;
            animation: attack-animation 0.4s ease-out forwards;
        }

        @keyframes attack-animation {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
                opacity: 0;
            }
            50% {
                opacity: 0.5;
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(360deg);
                opacity: 0;
            }
        }
        /* ‚ñ≤‚ñ≤‚ñ≤ Â§âÊõ¥ÁÆáÊâÄ ‚ñ≤‚ñ≤‚ñ≤ */
    </style>
</head>
<body class="bg-gray-900 text-gray-50">
    <div id="game-container" class="flex flex-row items-start">
        <div id="left-container">
            <div id="board-container" class="flex flex-col items-center mb-3">
                <div class="row">
                    <div class="hex-cell" data-slot-index="0"><span class="slot-number">1</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="1"><span class="slot-number">2</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="2"><span class="slot-number">3</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="3"><span class="slot-number">4</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="4"><span class="slot-number">5</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="5"><span class="slot-number">6</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="6"><span class="slot-number">7</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="7"><span class="slot-number">8</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="8"><span class="slot-number">9</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="9"><span class="slot-number">10</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="10"><span class="slot-number">11</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="11"><span class="slot-number">12</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="12"><span class="slot-number">13</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="13"><span class="slot-number">14</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="14"><span class="slot-number">15</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="15"><span class="slot-number">16</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="16"><span class="slot-number">17</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="17"><span class="slot-number">18</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="18"><span class="slot-number">19</span><div class="hex-inner"></div></div>
                </div>
            </div>
            <div id="message-box" class="mb-3 text-center"></div>
        </div>
        <div id="right-container">
            <div id="top-right-ui" class="flex flex-row justify-center mb-3">
                <div id="kill-count" class="text-center mr-2">ÂÄí„Åó„ÅüÊïµ„ÅÆÊï∞: 0/250<br>Lv: 1<br>Exp: 0/50</div>
                <div id="special-hand-container" class="flex justify-center">
                    <div class="special-card" data-special-card-index="0"></div>
                    <div class="special-card" data-special-card-index="1"></div>
                </div>
            </div>
            <div id="hand-container" class="flex justify-center mb-3">
                <div class="card" data-card-index="0"></div>
                <div class="card" data-card-index="1"></div>
                <div class="card" data-card-index="2"></div>
                <div class="card" data-card-index="3"></div>
                <div class="card" data-card-index="4"></div>
            </div>
            <div id="card-description" class="mb-3 text-center"></div>
            <div id="game-explanation" class="mb-3 text-left overflow-y-auto">
            </div>
        </div>
    </div>

    <div class="mt-4 flex justify-center items-center">
        <button id="reset-button" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded mr-2">„É™„Çª„ÉÉ„Éà</button>
        <button id="settings-button" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Ë®≠ÂÆö</button>
        <div class="ml-4 flex space-x-2">
            <div id="difficulty-indicator" class="w-4 h-4 rounded-full transition-colors" title="ÁèæÂú®„ÅÆÈõ£ÊòìÂ∫¶"></div>
            <div id="endless-mode-indicator" class="w-4 h-4 rounded-full transition-colors" title="„Ç®„É≥„Éâ„É¨„Çπ„É¢„Éº„Éâ"></div>
        </div>
        <div id="highscore-display" class="ml-4 text-lg text-yellow-400 font-bold" style="font-family: 'Press Start 2P', cursive;"></div>
    </div>

    <div id="settings-modal" class="hidden">
        <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 cursor-pointer"></div>
        <div id="modal-content" class="fixed bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-600 text-center">
            <h2 class="text-2xl font-bold mb-6">Ë®≠ÂÆö</h2>
            
            <div class="mb-5">
                <h3 class="text-lg mb-2">Èõ£ÊòìÂ∫¶</h3>
                <div class="flex justify-center space-x-2">
                    <button data-difficulty="easy" class="difficulty-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">„Ç§„Éº„Ç∏„Éº</button>
                    <button data-difficulty="normal" class="difficulty-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">„Éé„Éº„Éû„É´</button>
                    <button data-difficulty="hard" class="difficulty-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">„Éè„Éº„Éâ</button>
                    </div>
            </div>

            <div class="mb-8">
                <h3 class="text-lg mb-2">„É¢„Éº„Éâ</h3>
                <button id="endless-mode-button" class="w-full bg-purple-800 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors">„Ç®„É≥„Éâ„É¨„Çπ„É¢„Éº„Éâ: OFF</button>
            </div>

            <div class="flex justify-end space-x-4">
                <button id="cancel-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">„Ç≠„É£„É≥„Çª„É´</button>
                <button id="confirm-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Ê±∫ÂÆö</button>
            </div>
        </div>
    </div>
    <script>
// „Ç≤„Éº„É†Ë®≠ÂÆö
        const gameSettings = {
            // ‚ñº‚ñº‚ñº ÂÖ±ÈÄöË®≠ÂÆö ‚ñº‚ñº‚ñº
            initialHandSize: 5,
            boardSize: 19,
            cardTypes: ['‚ö°Ô∏è', 'üó°Ô∏è', 'üí•'],
            enemyTypes: ['üî•', 'üíß', '‚òÄÔ∏è', 'üå±', 'üëø'],
            enemyHpValues: {'üî•': 15,'üíß': 8,'‚òÄÔ∏è': 15,'üå±': 20,'üëø': 150},
            // ‚ñº‚ñº‚ñº Â§âÊõ¥ÁÆáÊâÄ ‚ñº‚ñº‚ñº
            attackEffectImages: {
                '‚ö°Ô∏è': 'https://www.google.com/favicon.ico',
                'üó°Ô∏è': 'https://www.yahoo.com/favicon.ico',
                'üí•': 'https://www.amazon.com/favicon.ico',
                'üíÄ': 'https://www.wikipedia.org/favicon.ico',
                'ü¶†': 'https://www.microsoft.com/favicon.ico',
                'üåä': 'https://www.apple.com/favicon.ico'
            },
            // ‚ñ≤‚ñ≤‚ñ≤ Â§âÊõ¥ÁÆáÊâÄ ‚ñ≤‚ñ≤‚ñ≤
            slotCoordinates: [
                [0, 0], [1, 0], [2, 0],
                [0.5, 1], [1.5, 1], [2.5, 1], [3.5, 1],
                [0, 2], [1, 2], [2, 2], [3, 2], [4, 2],
                [0.5, 3], [1.5, 3], [2.5, 3], [3.5, 3],
                [1, 4], [2, 4], [3, 4]
            ],
            adjacentSlots: [
                [1, 3, 4], [0, 2, 4, 5], [1, 5, 6],
                [0, 4, 7, 8], [0, 1, 3, 5, 8, 9], [1, 2, 4, 6, 9, 10], [2, 5, 10, 11],
                [3, 8, 12], [3, 4, 7, 9, 12, 13], [4, 5, 8, 10, 13, 14], [5, 6, 9, 11, 14, 15], [6, 10, 15],
                [7, 8, 13, 16], [8, 9, 12, 14, 16, 17], [9, 10, 13, 15, 17, 18], [10, 11, 14, 18],
                [12, 13, 17], [13, 14, 16, 18], [14, 15, 17]
            ],
            killsPerLevel: 5,
            levelUpThreshold: 50,
            specialCardChargeThreshold: 400,
            bossThresholdIncrement: 25,
            chainDamageMultiplier: 0.8,
            splashDamageMultiplier: 2,
            experiencePerKill: 10,
            experienceChainBonus: 4,
            cardDescriptions: {
                '‚ö°Ô∏è': '‚ö°Ô∏èÔºöÈõªÊíÉ„ÄÇÈö£Êé•„Åô„ÇãÂêå„ÅòÁ®ÆÈ°û„ÅÆÊïµ„Å´ËøΩÂä†„ÉÄ„É°„Éº„Ç∏„ÄÇ',
                'üó°Ô∏è': 'üó°Ô∏èÔºöÊñ¨ÊíÉ„ÄÇÊïµ„ÅÆÊúÄÂ§ßHP„ÅÆ1/5„ÅÆËøΩÂä†„ÉÄ„É°„Éº„Ç∏„ÄÇ',
                'üí•': 'üí•ÔºöÁàÜÁô∫„ÄÇÂë®Âõ≤„ÅÆÊïµ„ÅÆÊï∞„Å´Âøú„Åò„Å¶ËøΩÂä†„ÉÄ„É°„Éº„Ç∏„ÄÇ'
            },
            baseDamage: {
                '‚ö°Ô∏è': 10,
                'üó°Ô∏è': 15,
                'üí•': 10
            },
            specialCardTypes: ['üíÄ', 'ü¶†', 'üåä'],
            specialCardDescriptions: {
                'üíÄ': 'üíÄÔºöÂë™Á∏õ„ÄÇÂÖ®„Å¶„ÅÆÂêå„ÅòÁ®ÆÈ°û„ÅÆÊïµ„Å´„ÉÄ„É°„Éº„Ç∏„ÄÇ',
                'ü¶†': 'ü¶†ÔºöÊÑüÊüì„ÄÇÈö£Êé•„Åô„ÇãÊïµ„ÇíÂêåÂåñ„Åï„Åõ„ÉÄ„É°„Éº„Ç∏„ÄÇ',
                'üåä': 'üåäÔºöÊ¥•Ê≥¢„ÄÇÂÖ®„Å¶„ÅÆÊïµ„Å´„ÉÄ„É°„Éº„Ç∏„ÄÇ'
            },
            specialCardBaseDamage: {
                'üíÄ': 20,
                'ü¶†': 2,
                'üåä': 10
            },

            difficultySettings: {
                easy: {
                    killTarget: 100,
                    enemySpawnRatesInitial: [0.4, 0.6, 0, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.4, 0.5, 0, 0.1, 0],
                    finalGameRatesCount: 80,
                    enemySpawnRatesFinalGame: [0.3, 0.5, 0, 0.2, 0],
                    bossThresholdInitial: 80,
                },
                normal: {
                    killTarget: 150,
                    enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0],
                    finalGameRatesCount: 100,
                    enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0],
                    bossThresholdInitial: 50,
                },
                hard: {
                    killTarget: 250,
                    enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0],
                    finalGameRatesCount: 125,
                    enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0],
                    bossThresholdInitial: 50,
                }
            }
        };

        const gameState = {
            hand: [], board: [], selectedCardIndex: null, selectedSpecialCardIndex: null, killCount: 0, gameOver: false, handSelectionEnabled: true, playerLevel: 1, playerXp: 0, playerXpTotal: 0, expForNextLevel: 0, expAdded: 0, enemySpawnRates: [], isMidGameRatesActive: false, isFinalGameRatesActive: false, forcePurpleEnemy: false, forcePurpleEnemyCount: 0, forcePurpleEnemyThreshold: 0, bossExtraHpTimes: 0, turn: 1, specialHand: [null, null], specialCardChargeCounter: 0, specialCardChargeAdd: 400, emptySlotsPreviousTurn: [], difficulty: 'normal', isEndlessMode: false, emptySlotsCurrentTurn: []
        };

        const domElements = {
            handContainer: document.getElementById('hand-container'), specialHandContainer: document.getElementById('special-hand-container'), boardContainer: document.getElementById('board-container'), messageBox: document.getElementById('message-box'), killCountDisplay: document.getElementById('kill-count'), cardDescription: document.getElementById('card-description'), gameExplanation: document.getElementById('game-explanation'), handSlots: null, boardSlots: null, specialHandSlots: null, difficultyIndicator: document.getElementById('difficulty-indicator'), endlessModeIndicator: document.getElementById('endless-mode-indicator'), highscoreDisplay: document.getElementById('highscore-display'),
        };

        function applyDifficultySettings(difficulty) {
            const newSettings = gameSettings.difficultySettings[difficulty];
            if (newSettings) { Object.assign(gameSettings, newSettings); }
        }

        function generateExplanationText() {
            return `„Äê„Éò„ÉÉ„ÇØ„Çπ„Ç∞„É™„ÉÉ„Éâ„Éê„Éà„É´„Äë\n\n**ÁõÆÊ®ô**\n„ÄÄÊïµ„ÇíÂêàË®à${gameSettings.killTarget === Infinity ? '‚àû' : gameSettings.killTarget}‰ΩìÂÄí„Åô„Å®„Ç≤„Éº„É†„ÇØ„É™„Ç¢„Åß„ÅôÔºÅ\n\n**„Ç≤„Éº„É†„ÅÆÂü∫Êú¨ÁöÑ„Å™ÊµÅ„Çå**\n1.  **„Çø„Éº„É≥ÈñãÂßã**: Ââç„ÅÆ„Çø„Éº„É≥„Å´Á©∫„Å´„Å™„Å£„Åü„Éû„Çπ„Å´Êïµ„ÅåË£úÂÖÖ„Åï„Çå„Åæ„Åô„ÄÇ\n2.  **„Ç´„Éº„ÉâÈÅ∏Êäû**: ÊâãÊú≠„Åã„ÇâÊîªÊíÉ„Å´‰Ωø„ÅÑ„Åü„ÅÑ„Ç´„Éº„Éâ„Çí1ÊûöÈÅ∏„Å≥„Åæ„Åô„ÄÇ\n3.  **ÊîªÊíÉÂØæË±°ÈÅ∏Êäû**: „Éú„Éº„Éâ‰∏ä„ÅÆÊïµ„Åå„ÅÑ„Çã„Éû„Çπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÊîªÊíÉ„Åó„Åæ„Åô„ÄÇ\n4.  **ÊîªÊíÉÂÆüË°å**: ÈÅ∏„Çì„Å†„Ç´„Éº„Éâ„ÅÆÂäπÊûú„ÅßÊïµ„Å´„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇÊïµ„ÅÆHP„Åå0„Å´„Å™„Çã„Å®ÂÄí„Åï„Çå„Åæ„Åô„ÄÇ\n5.  **„Ç´„Éº„ÉâË£úÂÖÖ„Å®ÊàêÈï∑**: Êïµ„ÇíÂÄí„Åô„Å®Êñ∞„Åó„ÅÑ„Ç´„Éº„Éâ„ÅåÊâãÊú≠„Å´Ë£úÂÖÖ„Åï„Çå„Åæ„Åô„ÄÇ\n„ÄÄ„ÄÄÂÄí„Åó„ÅüÊïµ„ÅÆÊï∞„Å´Âøú„Åò„Å¶ÁµåÈ®ìÂÄ§„ÅåÂæó„Çâ„Çå„ÄÅ„É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åô„Çã„Å®ÊîªÊíÉÂäõ„Åå‰∏ä„Åå„Çä„Åæ„Åô„ÄÇ\n„ÄÄ„ÄÄÊïµ„ÇíÂêåÊôÇ„Å´ÂÄí„Åô„Å®ÁµåÈ®ìÂÄ§„Éú„Éº„Éä„ÇπÔºÅ\n\n**„Ç´„Éº„Éâ„ÅÆÁ®ÆÈ°û„Å®ÂäπÊûú**\n* **ÈÄöÂ∏∏„Ç´„Éº„Éâ**:\n    * ‚ö°Ô∏è (ÈõªÊíÉ)ÔºöÈö£Êé•„Åô„ÇãÂêå„ÅòÁ®ÆÈ°û„ÅÆÊïµ„Å´ÈÄ£Èéñ„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n    * üó°Ô∏è (Êñ¨ÊíÉ)ÔºöÊïµ„ÅÆÊúÄÂ§ßHP„ÅÆ1/5„ÅÆËøΩÂä†„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n    * üí• (ÁàÜÁô∫)ÔºöÂë®Âõ≤„ÅÆÊïµ„ÅÆÊï∞„Å´Âøú„Åò„Å¶ÂàÜÊï£„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n* **„Çπ„Éö„Ç∑„É£„É´„Ç´„Éº„Éâ**: ÁµåÈ®ìÂÄ§„ÇíÁç≤Âæó„Åô„Çã„Åì„Å®„Åß„ÉÅ„É£„Éº„Ç∏„Åï„Çå„ÄÅÊâãÊú≠„Å´ËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ\n    * üíÄ (Âë™Á∏õ)ÔºöÂÖ®„Å¶„ÅÆÂêå„ÅòÁ®ÆÈ°û„ÅÆÊïµ„Å´Âë™Á∏õ„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n    * ü¶† (ÊÑüÊüì)ÔºöÈö£Êé•„Åô„ÇãÊïµ„ÇíÂêå„ÅòÁ®ÆÈ°û„Å´Â§âÂåñ„Åï„ÅõÊÑüÊüì„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n    * üåä (Ê¥•Ê≥¢)ÔºöÂÖ®„Å¶„ÅÆÊïµ„Å´Ê¥•Ê≥¢„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åô„ÄÇ\n\n**Êïµ„Å´„Å§„ÅÑ„Å¶**\n„ÄÄÊïµ„Å´„ÅØüî•„ÄÅüíß„ÄÅ‚òÄÔ∏è„ÄÅüå±„ÄÅüëø„ÅÆ5Á®ÆÈ°û„Åå„ÅÑ„Åæ„Åô„ÄÇ\n„ÄÄÊïµ„ÅØÂÄí„Åô„Åî„Å®„Å´Âº∑„Åè„Å™„Å£„Å¶Ë£úÂÖÖ„Åï„Çå„Åæ„Åô„ÄÇ\n„ÄÄÁâπÂÆö„ÅÆË®é‰ºêÊï∞„Å´ÈÅî„Åô„Çã„Å®„ÄÅ„Çà„ÇäÂº∑Âäõ„Å™„Éú„ÇπÊïµÔºàüëøÔºâ„ÅåÂº∑Âà∂ÁöÑ„Å´Âá∫Áèæ„Åô„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ\n\n**„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº**\n„ÄÄÊâãÊú≠„ÅåÂÖ®„Å¶„Å™„Åè„Å™„Çã„Å®„ÄÅ„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Å®„Å™„Çä„Åæ„Åô„ÄÇ\n`;
        }
        
        function getHighScoreKey() { return `hex-grid-battle-highscore-${gameState.difficulty}-${gameState.isEndlessMode ? 'on' : 'off'}`; }
        function saveHighScore(score) { const key = getHighScoreKey(); const currentHighScore = parseInt(localStorage.getItem(key) || '0'); if (score > currentHighScore) { localStorage.setItem(key, score); updateHighScoreUI(); } }
        function loadHighScore() { const key = getHighScoreKey(); return parseInt(localStorage.getItem(key) || '0'); }
        function updateHighScoreUI() { const highScore = loadHighScore(); domElements.highscoreDisplay.textContent = `HighScore: ${highScore}`; }

        function updateStatusIndicators() {
            domElements.difficultyIndicator.className = 'w-4 h-4 rounded-full transition-colors';
            domElements.endlessModeIndicator.className = 'w-4 h-4 rounded-full transition-colors';
            switch (gameState.difficulty) {
                case 'easy': domElements.difficultyIndicator.classList.add('bg-blue-600'); break;
                case 'normal': domElements.difficultyIndicator.classList.add('bg-yellow-500'); break;
                case 'hard': domElements.difficultyIndicator.classList.add('bg-red-600'); break;
            }
            if (gameState.isEndlessMode) { domElements.endlessModeIndicator.classList.add('bg-purple-600'); } else { domElements.endlessModeIndicator.classList.add('bg-purple-800'); }
        }

        // ‚ñº‚ñº‚ñº Â§âÊõ¥ÁÆáÊâÄ ‚ñº‚ñº‚ñº
        function showAttackEffect(slotIndex, cardType) {
            const imageUrl = gameSettings.attackEffectImages[cardType];
            if (!imageUrl) return;

            const cellElement = document.querySelector(`.hex-cell[data-slot-index="${slotIndex}"]`);
            if (!cellElement) return;

            const effectImage = document.createElement('img');
            effectImage.src = imageUrl;
            effectImage.className = 'attack-effect';

            cellElement.appendChild(effectImage);

            setTimeout(() => {
                if (cellElement.contains(effectImage)) {
                    cellElement.removeChild(effectImage);
                }
            }, 400);
        }
        // ‚ñ≤‚ñ≤‚ñ≤ Â§âÊõ¥ÁÆáÊâÄ ‚ñ≤‚ñ≤‚ñ≤

        function initializeGame() {
            applyDifficultySettings(gameState.difficulty);
            if (gameState.isEndlessMode) { gameSettings.killTarget = Infinity; }
            Object.assign(gameState, { hand: [], board: [], selectedCardIndex: null, selectedSpecialCardIndex: null, killCount: 0, gameOver: false, handSelectionEnabled: true, playerLevel: 1, playerXp: 0, playerXpTotal: 0, expForNextLevel: 0, expAdded: 0, specialCardChargeCounter: 0, specialCardChargeAdd: 400, emptySlotsPreviousTurn: [], emptySlotsCurrentTurn: [], specialHand: [null, null], enemySpawnRates: [...gameSettings.enemySpawnRatesInitial], forcePurpleEnemyCount: gameSettings.bossThresholdInitial, forcePurpleEnemyThreshold: gameSettings.bossThresholdIncrement, isMidGameRatesActive: false, isFinalGameRatesActive: false, forcePurpleEnemy: false, bossExtraHpTimes: 0 });
            domElements.gameExplanation.textContent = generateExplanationText();
            updateMessageBoxUI('„Ç≤„Éº„É†ÈñãÂßã');
            updateKillCountUI();
            updateStatusIndicators();
            updateHighScoreUI();
            for (let i = 0; i < gameSettings.initialHandSize; i++) { drawCard(); }
            gameState.board = Array(gameSettings.boardSize).fill(null);
            for (let i = 0; i < gameSettings.boardSize; i++) { spawnEnemy(i); }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            domElements.boardSlots = document.querySelectorAll('#board-container .hex-cell');
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            if (!domElements.handContainer.listener) { domElements.handContainer.addEventListener('click', (domElements.handContainer.listener = handleHandClick)); }
            if (!domElements.boardContainer.listener) { domElements.boardContainer.addEventListener('click', (domElements.boardContainer.listener = handleBoardClick)); }
            if (!domElements.specialHandContainer.listener) { domElements.specialHandContainer.addEventListener('click', (domElements.specialHandContainer.listener = handleSpecialHandClick)); }
            replenishEnemies();
            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            updateMessageBoxUI('ÊâãÊú≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
            recordCurrentEmptySlots();
        }

        function replenishEnemies() {
            gameState.emptySlotsPreviousTurn.forEach(emptySlotIndex => { if (!gameState.board[emptySlotIndex] || gameState.board[emptySlotIndex].empty) { spawnEnemy(emptySlotIndex); } });
            gameState.emptySlotsPreviousTurn = [];
            updateBoardUI();
        }

        function recordCurrentEmptySlots() { gameState.emptySlotsCurrentTurn = gameState.board.reduce((acc, cell, index) => { if (!cell || cell.empty) { acc.push(index); } return acc; }, []); }
        function drawCard() { if (gameState.hand.length < 5) { const randomCardType = gameSettings.cardTypes[Math.floor(Math.random() * gameSettings.cardTypes.length)]; gameState.hand.push(randomCardType); } }
        function spawnEnemy(slotIndex) { const enemyType = generateEnemyType(); gameState.bossExtraHpTimes = (enemyType === 'üëø') ? 2 : 0; const newHp = gameSettings.enemyHpValues[enemyType] + Math.floor(gameState.killCount / 5) * 3 + gameState.playerLevel * gameState.bossExtraHpTimes; gameState.board[slotIndex] = { enemy: { type: enemyType, hp: newHp, maxHp: newHp }, empty: false }; }
        function handleHandClick(event) { if (!gameState.handSelectionEnabled || gameState.gameOver) return; const cardElement = event.target.closest('.card'); if (cardElement) { const cardIndex = parseInt(cardElement.dataset.cardIndex); if (gameState.hand[cardIndex] !== undefined) { selectCard(cardIndex); } } }
        function handleBoardClick(event) { if (gameState.selectedCardIndex === null && gameState.selectedSpecialCardIndex === null || gameState.gameOver) return; const hexCell = event.target.closest('.hex-cell'); if (hexCell) { const slotIndex = parseInt(hexCell.dataset.slotIndex); attack(slotIndex); } }
        function handleSpecialHandClick(event) { if (gameState.gameOver) return; const cardElement = event.target.closest('.special-card'); if (cardElement) { const cardIndex = parseInt(cardElement.dataset.specialCardIndex); if (gameState.specialHand[cardIndex]) { selectCard(cardIndex + 5); } } }

        function updateHandUI() {
            domElements.handContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.cardIndex = i;
                if (gameState.hand[i] !== undefined) { 
                    card.textContent = gameState.hand[i];
                    if (gameState.handSelectionEnabled) { card.classList.add('cursor-pointer'); card.classList.remove('opacity-50', 'cursor-not-allowed'); } else { card.classList.add('opacity-50', 'cursor-not-allowed', 'cursor-default'); }
                    if (gameState.selectedCardIndex === i) { card.classList.add('selected'); }
                } else { card.classList.add('opacity-30', 'cursor-not-allowed'); card.textContent = ''; }
                domElements.handContainer.appendChild(card);
            }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            updateCardDescriptionUI();
        }

        function updateSpecialHandUI() {
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            for (let i = 0; i < 2; i++) {
                const card = domElements.specialHandSlots[i];
                card.classList.remove('selected', 'opacity-30', 'cursor-not-allowed', 'cursor-pointer'); 
                if (gameState.specialHand[i]) { card.textContent = gameState.specialHand[i]; card.classList.add('cursor-pointer'); } else { card.classList.add('opacity-30', 'cursor-not-allowed'); card.textContent = ''; }
                if (gameState.selectedSpecialCardIndex === i) { card.classList.add('selected'); }
            }
            updateCardDescriptionUI();
        }

        function updateBoardUI() {
            domElements.boardContainer.querySelectorAll('.hex-cell').forEach((cell) => {
                const slotIndex = parseInt(cell.dataset.slotIndex);
                const cellInner = cell.querySelector('.hex-inner');
                cellInner.className = 'hex-inner';
                if (gameState.board[slotIndex] && !gameState.board[slotIndex].empty) {
                    const enemy = gameState.board[slotIndex].enemy;
                    cellInner.textContent = enemy.type;
                    cellInner.innerHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%; background-color: ${enemy.hp <= enemy.maxHp / 2 ? 'red' : enemy.hp <= enemy.maxHp * 0.75 ? 'yellow' : 'green'};"></div><span class="hp-text">${enemy.hp}</span></div>`;
                    switch (enemy.type) {
                        case 'üî•': cellInner.classList.add('bg-red-500'); break;
                        case 'üíß': cellInner.classList.add('bg-blue-500'); break;
                        case '‚òÄÔ∏è': cellInner.classList.add('bg-yellow-500'); break;
                        case 'üå±': cellInner.classList.add('bg-green-500'); break;
                        case 'üëø': cellInner.classList.add('bg-purple-500'); break;
                    }
                } else { cellInner.classList.add('bg-gray-400'); cellInner.textContent = 'Empty'; }
            });
        }

        function updateKillCountUI() {
            const expBarWidth = (gameState.expForNextLevel / gameSettings.levelUpThreshold) * 100;
            const expBar = `<div style="width: 100%; background-color: #4b5563; border-radius: 0.25rem; margin-top: 0.25rem; position: relative; height: 0.6rem;"><div style="width: ${expBarWidth}%; background-color: #86ef7d; height: 100%; border-radius: 0.25rem;"></div></div>`;
            const targetDisplay = gameSettings.killTarget === Infinity ? '‚àû' : gameSettings.killTarget;
            domElements.killCountDisplay.innerHTML = `ÂÄí„Åó„ÅüÊïµ„ÅÆÊï∞: ${gameState.killCount}/${targetDisplay}<br>Lv: ${gameState.playerLevel}<br>Exp: ${gameState.playerXpTotal}  (+${gameState.expAdded})${expBar}`;
        }

        function updateCardDescriptionUI() {
            let description = 'ÈÅ∏Êäû„Åó„Åü„Ç´„Éº„Éâ„ÅÆÂäπÊûú„ÇíË°®Á§∫';
            let damageText = '';
            if (gameState.selectedCardIndex !== null) {
                const cardType = gameState.hand[gameState.selectedCardIndex];
                description = gameSettings.cardDescriptions[cardType] || description;
                const baseDamage = gameSettings.baseDamage[cardType] || 0;
                damageText = `<span class="damage-text">Âü∫Êú¨„ÉÄ„É°„Éº„Ç∏: ${baseDamage + gameState.playerLevel}</span>`;
            } else if (gameState.selectedSpecialCardIndex !== null) {
                const cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                description = gameSettings.specialCardDescriptions[cardType] || description;
                const baseDamage = gameSettings.specialCardBaseDamage[cardType] || 0;
                damageText = `<span class="damage-text">Âü∫Êú¨„ÉÄ„É°„Éº„Ç∏: ${baseDamage + gameState.playerLevel}</span>`;
            }
            domElements.cardDescription.innerHTML = `${description}<br>${damageText}`;
        }

        function updateMessageBoxUI(message) { domElements.messageBox.textContent = message; }
        function selectCard(index) {
            if (gameState.gameOver || !gameState.handSelectionEnabled) return;
            if (index >= 0 && index < 5) { gameState.selectedCardIndex = index; gameState.selectedSpecialCardIndex = null; } else { gameState.selectedSpecialCardIndex = index - 5; gameState.selectedCardIndex = null; }
            updateHandUI(); updateSpecialHandUI(); updateCardDescriptionUI(); updateMessageBoxUI('ÊîªÊíÉ„Åô„Çã„Éû„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        }

        // ‚ñº‚ñº‚ñº Â§âÊõ¥ÁÆáÊâÄ ‚ñº‚ñº‚ñº
        function attack(slotIndex) {
            if (gameState.gameOver) return;
            let cardType = null, baseDamage = 0, selectedIndex = null;
            if (gameState.selectedCardIndex !== null) { cardType = gameState.hand[gameState.selectedCardIndex]; baseDamage = gameSettings.baseDamage[cardType] + gameState.playerLevel; selectedIndex = gameState.selectedCardIndex; } else if (gameState.selectedSpecialCardIndex !== null) { cardType = gameState.specialHand[gameState.selectedSpecialCardIndex]; baseDamage = gameSettings.specialCardBaseDamage[cardType] + gameState.playerLevel; selectedIndex = gameState.selectedSpecialCardIndex; } else { updateMessageBoxUI('ÊâãÊú≠„ÇíÂÖà„Å´ÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ'); return; }
            if (!gameState.board[slotIndex] || gameState.board[slotIndex].empty) { updateMessageBoxUI('Á©∫„ÅÆ„Éû„Çπ„Å´„ÅØÊîªÊíÉ„Åß„Åç„Åæ„Åõ„Çì'); return; }

            let enemiesKilled = 0;
            const attackedSlot = gameState.board[slotIndex];
            
            switch (cardType) {
                case '‚ö°Ô∏è': {
                    const queue = [slotIndex];
                    const damagedSlots = new Set();
                    while (queue.length > 0) {
                        const currentSlotIndex = queue.shift();
                        if (damagedSlots.has(currentSlotIndex)) continue;
                        damagedSlots.add(currentSlotIndex);
                        const damage = currentSlotIndex === slotIndex ? baseDamage : Math.floor(baseDamage * gameSettings.chainDamageMultiplier);
                        const currentCell = gameState.board[currentSlotIndex];
                        if (currentCell && !currentCell.empty) {
                            currentCell.enemy.hp -= damage;
                            showAttackEffect(currentSlotIndex, cardType);
                            if (currentCell.enemy.hp <= 0) { currentCell.empty = true; enemiesKilled++; handleBossSpawn(); }
                            const adjacentSlots = gameSettings.adjacentSlots[currentSlotIndex] || [];
                            for (const adjacentSlotIndex of adjacentSlots) { if (gameState.board[adjacentSlotIndex] && !gameState.board[adjacentSlotIndex].empty && gameState.board[adjacentSlotIndex].enemy.type === attackedSlot.enemy.type) { queue.push(adjacentSlotIndex); } }
                        }
                    }
                    break;
                }
                case 'üó°Ô∏è': {
                    let damage = baseDamage + Math.floor(attackedSlot.enemy.maxHp / 5);
                    attackedSlot.enemy.hp -= damage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case 'üí•': {
                    const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                    const adjacentEnemies = adjacentSlots.filter(index => gameState.board[index] && !gameState.board[index].empty);
                    const splashDamage = adjacentEnemies.length > 0 ? Math.floor((baseDamage * gameSettings.splashDamageMultiplier) / adjacentEnemies.length) : 0;
                    adjacentEnemies.forEach(adjacentSlotIndex => {
                        const cell = gameState.board[adjacentSlotIndex];
                        cell.enemy.hp -= splashDamage;
                        showAttackEffect(adjacentSlotIndex, cardType);
                        if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                    });
                    attackedSlot.enemy.hp -= baseDamage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case 'üíÄ': {
                    const targetEnemyType = attackedSlot.enemy.type;
                    gameState.board.forEach((cell, index) => {
                        if (cell && !cell.empty && cell.enemy.type === targetEnemyType) {
                            cell.enemy.hp -= baseDamage;
                            showAttackEffect(index, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    break;
                }
                case 'ü¶†': {
                    const targetEnemyType = attackedSlot.enemy.type;
                    const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                    adjacentSlots.forEach(adjIndex => {
                        const cell = gameState.board[adjIndex];
                        if (cell && !cell.empty) {
                            cell.enemy.type = targetEnemyType;
                            cell.enemy.hp -= Math.floor(baseDamage * 0.3);
                            showAttackEffect(adjIndex, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    attackedSlot.enemy.hp -= baseDamage;
                    showAttackEffect(slotIndex, cardType);
                    if (attackedSlot.enemy.hp <= 0) { attackedSlot.empty = true; enemiesKilled++; handleBossSpawn(); }
                    break;
                }
                case 'üåä': {
                    gameState.board.forEach((cell, index) => {
                        if (cell && !cell.empty) {
                            cell.enemy.hp -= baseDamage;
                            showAttackEffect(index, cardType);
                            if (cell.enemy.hp <= 0) { cell.empty = true; enemiesKilled++; handleBossSpawn(); }
                        }
                    });
                    break;
                }
            }
            // ‚ñ≤‚ñ≤‚ñ≤ Â§âÊõ¥ÁÆáÊâÄ ‚ñ≤‚ñ≤‚ñ≤

            updateMessageBoxUI('ÊîªÊíÉÔºÅ');
            if (selectedIndex !== null) {
                if (gameState.selectedCardIndex !== null) { gameState.hand.splice(gameState.selectedCardIndex, 1); } else if (gameState.selectedSpecialCardIndex !== null) { gameState.specialHand[gameState.selectedSpecialCardIndex] = null; }
            }
            gameState.selectedCardIndex = null; gameState.selectedSpecialCardIndex = null; gameState.handSelectionEnabled = false;
            domElements.handSlots.forEach(card => { if (!card.classList.contains('opacity-30')) { card.classList.add('disabled'); } });
            domElements.specialHandSlots.forEach(card => { if (!card.classList.contains('opacity-30')) { card.classList.add('disabled'); } });
            gameState.killCount += enemiesKilled;
            updateHandUI(); updateSpecialHandUI(); updateBoardUI(); handleExperience(enemiesKilled); updateKillCountUI();

            setTimeout(() => {
                const cardsToDraw = Math.min(enemiesKilled, 5 - gameState.hand.length);
                for (let i = 0; i < cardsToDraw; i++) { drawCard(); }
                recordCurrentEmptySlots();
                const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);
                if (isBoardCompletelyEmpty) { gameState.emptySlotsPreviousTurn = Array.from({ length: gameSettings.boardSize }, (_, i) => i); replenishEnemies(); gameState.emptySlotsCurrentTurn = []; } else { replenishEnemies(); gameState.emptySlotsPreviousTurn = [...gameState.emptySlotsCurrentTurn]; gameState.emptySlotsCurrentTurn = []; }
                gameState.handSelectionEnabled = true;
                domElements.handSlots.forEach(card => { card.classList.remove('disabled'); });
                domElements.specialHandSlots.forEach(card => { card.classList.remove('disabled'); });
                updateHandUI(); updateSpecialHandUI(); updateBoardUI(); updateMessageBoxUI('ÊâãÊú≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                if (gameState.killCount >= gameSettings.killTarget) { gameState.gameOver = true; endGame(); } else if (gameState.hand.length === 0 && gameState.specialHand.every(card => card === null) && gameState.board.some(cell => cell && !cell.empty)) { gameState.gameOver = true; endGame(); return; }
            }, 400);
            gameState.handSelectionEnabled = true;
        }

        function handleBossSpawn() { if (gameState.killCount >= gameState.forcePurpleEnemyCount) { gameState.forcePurpleEnemy = true; gameState.forcePurpleEnemyCount += gameState.forcePurpleEnemyThreshold; } }
        function generateEnemyType() { if (gameState.forcePurpleEnemy) { gameState.forcePurpleEnemy = false; return 'üëø'; } else { let rand = Math.random(); let cumulativeProbability = 0; for (let i = 0; i < gameState.enemySpawnRates.length; i++) { cumulativeProbability += gameState.enemySpawnRates[i]; if (rand < cumulativeProbability) { return gameSettings.enemyTypes[i]; } } return gameSettings.enemyTypes[gameSettings.enemyTypes.length - 1]; } }

        function handleExperience(enemiesKilled) {
            const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);
            gameState.expAdded = isBoardCompletelyEmpty ? gameSettings.specialCardChargeThreshold : (enemiesKilled * gameSettings.experiencePerKill) + (enemiesKilled > 0 ? (enemiesKilled - 1) * gameSettings.experienceChainBonus : 0);
            gameState.playerXpTotal += gameState.expAdded;
            gameState.playerXp += gameState.expAdded;
            gameState.specialCardChargeCounter += gameState.expAdded;
            if (gameState.killCount >= gameSettings.midGameRatesCount && !gameState.isMidGameRatesActive) { gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesMidGame]; gameState.isMidGameRatesActive = true; } else if (gameState.killCount >= gameSettings.finalGameRatesCount && !gameState.isFinalGameRatesActive) { gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesFinalGame]; gameState.isFinalGameRatesActive = true; }
            while (gameState.playerXp >= gameSettings.levelUpThreshold) { gameState.playerLevel++; gameState.playerXp -= gameSettings.levelUpThreshold; }
            gameState.expForNextLevel = gameState.playerXp % gameSettings.levelUpThreshold;
            while (gameState.specialCardChargeCounter >= gameState.specialCardChargeAdd) { gameState.specialCardChargeAdd += gameSettings.specialCardChargeThreshold; addSpecialCardToHand(); updateSpecialHandUI(); }
        }

        function addSpecialCardToHand() { const emptySlotIndex = gameState.specialHand.findIndex(card => card === null); if (emptySlotIndex !== -1) { const randomCardType = gameSettings.specialCardTypes[Math.floor(Math.random() * gameSettings.specialCardTypes.length)]; gameState.specialHand[emptySlotIndex] = randomCardType; } }

        function endGame() {
            domElements.handContainer.classList.add('disabled-overlay');
            domElements.boardContainer.classList.add('disabled-overlay');
            domElements.specialHandContainer.classList.add('disabled-overlay');
            const normalCardCount = gameState.hand.length;
            const specialCardCount = gameState.specialHand.filter(card => card !== null).length;
            const score = gameState.playerXpTotal + (normalCardCount * 30) + (specialCardCount * 100);
            saveHighScore(score);
            const isClear = gameState.killCount >= gameSettings.killTarget;
            if (isClear) { updateMessageBoxUI(`„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ Score: ${score}`); domElements.messageBox.classList.add('message-box-clear'); } else { updateMessageBoxUI(`„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº Score: ${score}`); domElements.messageBox.classList.add('message-box-gameover'); }
        }
        
        function resetGame() {
            domElements.handContainer.classList.remove('disabled-overlay');
            domElements.boardContainer.classList.remove('disabled-overlay');
            domElements.specialHandContainer.classList.remove('disabled-overlay');
            domElements.messageBox.classList.remove('message-box-clear', 'message-box-gameover');
            initializeGame();
        }

        document.getElementById('reset-button').addEventListener('click', resetGame);
        
        const settingsModal = document.getElementById('settings-modal'), openSettingsButton = document.getElementById('settings-button'), cancelButton = document.getElementById('cancel-button'), confirmButton = document.getElementById('confirm-button'), modalOverlay = document.getElementById('modal-overlay'), difficultyButtons = document.querySelectorAll('.difficulty-button'), endlessModeButton = document.getElementById('endless-mode-button');
        let tempDifficulty, tempIsEndlessMode;
        function updateDifficultyButtonsUI() { difficultyButtons.forEach(button => { if (button.dataset.difficulty === tempDifficulty) { button.classList.add('scale-110'); button.classList.remove('scale-90', 'opacity-75'); } else { button.classList.add('scale-90', 'opacity-75'); button.classList.remove('scale-110'); } }); }
        function updateEndlessModeButtonUI() { if (tempIsEndlessMode) { endlessModeButton.textContent = '„Ç®„É≥„Éâ„É¨„Çπ„É¢„Éº„Éâ: ON'; endlessModeButton.classList.replace('bg-purple-800', 'bg-purple-600'); } else { endlessModeButton.textContent = '„Ç®„É≥„Éâ„É¨„Çπ„É¢„Éº„Éâ: OFF'; endlessModeButton.classList.replace('bg-purple-600', 'bg-purple-800'); } }
        function openModal() { tempDifficulty = gameState.difficulty; tempIsEndlessMode = gameState.isEndlessMode; updateDifficultyButtonsUI(); updateEndlessModeButtonUI(); settingsModal.classList.remove('hidden'); }
        function closeModal() { settingsModal.classList.add('hidden'); }
        difficultyButtons.forEach(button => { button.addEventListener('click', () => { tempDifficulty = button.dataset.difficulty; updateDifficultyButtonsUI(); }); });
        endlessModeButton.addEventListener('click', () => { tempIsEndlessMode = !tempIsEndlessMode; updateEndlessModeButtonUI(); });
        openSettingsButton.addEventListener('click', openModal);
        cancelButton.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', closeModal);
        confirmButton.addEventListener('click', () => { const difficultyChanged = gameState.difficulty !== tempDifficulty; const endlessModeChanged = gameState.isEndlessMode !== tempIsEndlessMode; if (difficultyChanged || endlessModeChanged) { gameState.difficulty = tempDifficulty; gameState.isEndlessMode = tempIsEndlessMode; resetGame(); } closeModal(); });
        
        initializeGame();
        
    </script>
</body>
</html>
