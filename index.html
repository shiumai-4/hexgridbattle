<!DOCTYPE html>
<html>
<head>
    <title>ãƒ˜ãƒƒã‚¯ã‚¹ã‚°ãƒªãƒƒãƒ‰ãƒãƒˆãƒ«</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {font-family: 'Arial', sans-serif;margin: 0;padding: 0;background-color: #111827;color: #f9fafb;display: flex;justify-content: center;align-items: center;min-height: 100vh;background-size: cover;background-position: center;flex-direction: column;}
        #game-container {display: flex;flex-direction: row;align-items: flex-start;padding: 1.25rem;max-width: 90%;width: 100%;box-sizing: border-box;}
        #board-container {display: flex;flex-direction: column;align-items: center;margin-bottom: 0.75rem;width: 100%;max-width: 600px;margin-right: 2rem;}
        .row {display: flex;justify-content: center;margin-bottom: 0.25rem;width: 100%;}
        .hex-cell {width: 56px;height: 64px;display: flex;justify-content: center;align-items: center;margin: 0 0.25rem;border-radius: 0.5rem;font-size: 0.75rem;position: relative;animation: new-ally-fade-in 0.3s ease-out forwards;}
        .hex-inner {width: 100%;height: 100%;background-color: #4b5563;border-radius: 0.5rem;display: flex;justify-content: center;align-items: center;position: absolute;top: 0;left: 0;border: 2px solid;border-color: #6b7280;}
        .hex-Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ² {background-color: #86ef7d;}
        .hex-Ğ¾ÑĞ»Ğ°Ğ±Ğ»ĞµĞ½ {background-color: #f43f5e;}
        .enemy-Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ² {color: #ffffff;}
        .enemy-Ğ¾ÑĞ»Ğ°Ğ±Ğ»ĞµĞ½ {color: #ffffff;}
        .slot-number {position: absolute;top: 0.15rem;left: 0.25rem;font-size: 0.5rem;color: #cbd5e0;z-index: 10;}
        #message-box {background-color: #17233c;color: #f9fafb;padding: 0.5rem;margin-bottom: 0.75rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 600px;border: 2px solid;border-color: #6b7280;}
        .message-box-clear { background-color: #ffe35a !important; color: #062b08 !important; border-color: #fbaf21 !important; }
        .message-box-gameover { background-color: #aa2ac0 !important; color: #f3ffae !important; border-color: #f398ff !important; }
        #right-container {display: flex;flex-direction: column;align-items: center;margin-left: 2rem;}
        #card-description {background-color: #101520;color: #f9fafb;height: 4.0rem;padding: 0.5rem;margin-bottom: 2.5rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        #hand-container {display: flex;justify-content: center;margin-bottom: 0.95rem;width: 100%;max-width: 600px;}
        .card {width: 64px;height: 80px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #374151;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.3);}
        .card.selected {background-color: #6b7280;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.4);}
        .card.disabled {opacity: 0.5;cursor: not-allowed;}
        #top-right-ui {display: flex;flex-direction: row;align-items: center;justify-content: center;margin-bottom: 0.75rem;width: 100%;max-width: 400px;}
        #special-hand-container {display: flex;justify-content: center;align-items: center;margin-left: 0.5rem;margin-bottom: 0.75rem;}
        .special-card {width: 64px;height: 90px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #6b46c1;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .special-card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);}
        .special-card.selected {background-color: #7763b1;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);}
        .special-card.disabled {opacity: 0.5;cursor: not-allowed;}
        #kill-count {background-color: #101520;color: #f9fafb;padding: 0.5rem;border-radius: 0.5rem;text-align: center;margin-right: 0.5rem;margin-left: 0.2rem;margin-bottom: 0.75rem;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        .hp-bar {width: 80%;height: 0.5rem;background-color: #6b7280;border-radius: 0.25rem;margin-top: 0.25rem;position: absolute;bottom: 0.25rem;left: 10%;}
        .hp-fill {height: 100%;background-color: #86ef7d;border-radius: 0.25rem;width: 100%;}
        .hp-text {position: absolute;top: -0.6rem;right: 0.04rem;font-size: 0.7rem;color: #333;z-index: 1;}
        .damage-text {font-size: 0.9rem; }
        #game-explanation { height: 5.5em; overflow-y: auto; border: 2px solid #6b7280; background-color: #201c10; color: #f9fafb; padding: 0.5rem; border-radius: 0.5rem;  white-space: pre-line; text-align: left; margin-bottom: 0.75rem; max-width: 400px; width: 100%; box-sizing: border-box;}
        @keyframes new-ally-fade-in { 0% { opacity: 0.5; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }
        .disabled-overlay { opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body class="bg-gray-900 text-gray-50">
    <div id="game-container" class="flex flex-row items-start">
        <div id="left-container">
            <div id="board-container" class="flex flex-col items-center mb-3">
                <div class="row">
                    <div class="hex-cell" data-slot-index="0"><span class="slot-number">1</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="1"><span class="slot-number">2</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="2"><span class="slot-number">3</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="3"><span class="slot-number">4</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="4"><span class="slot-number">5</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="5"><span class="slot-number">6</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="6"><span class="slot-number">7</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="7"><span class="slot-number">8</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="8"><span class="slot-number">9</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="9"><span class="slot-number">10</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="10"><span class="slot-number">11</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="11"><span class="slot-number">12</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="12"><span class="slot-number">13</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="13"><span class="slot-number">14</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="14"><span class="slot-number">15</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="15"><span class="slot-number">16</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="16"><span class="slot-number">17</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="17"><span class="slot-number">18</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="18"><span class="slot-number">19</span><div class="hex-inner"></div></div>
                </div>
            </div>
            <div id="message-box" class="mb-3 text-center"></div>
        </div>
        <div id="right-container">
            <div id="top-right-ui" class="flex flex-row justify-center mb-3">
                <div id="kill-count" class="text-center mr-2">å€’ã—ãŸæ•µã®æ•°: 0/250<br>Lv: 1<br>Exp: 0/50</div>
                <div id="special-hand-container" class="flex justify-center">
                    <div class="special-card" data-special-card-index="0"></div>
                    <div class="special-card" data-special-card-index="1"></div>
                </div>
            </div>
            <div id="hand-container" class="flex justify-center mb-3">
                <div class="card" data-card-index="0"></div>
                <div class="card" data-card-index="1"></div>
                <div class="card" data-card-index="2"></div>
                <div class="card" data-card-index="3"></div>
                <div class="card" data-card-index="4"></div>
            </div>
            <div id="card-description" class="mb-3 text-center"></div>
            <div id="game-explanation" class="mb-3 text-left overflow-y-auto">
            </div>
        </div>
    </div>
    <script>
        // ã‚²ãƒ¼ãƒ è¨­å®š
        const gameSettings = {
            initialHandSize: 5,
            boardSize: 19,
            cardTypes: ['âš¡ï¸', 'ğŸ—¡ï¸', 'ğŸ’¥'],
            enemyTypes: ['ğŸ”¥', 'ğŸ’§', 'â˜€ï¸', 'ğŸŒ±', 'ğŸ‘¿'],
            enemyHpValues: {'ğŸ”¥': 15,'ğŸ’§': 8,'â˜€ï¸': 15,'ğŸŒ±': 20,'ğŸ‘¿': 150},
            slotCoordinates: [
                [0, 0], [1, 0], [2, 0],
                [0.5, 1], [1.5, 1], [2.5, 1], [3.5, 1],
                [0, 2], [1, 2], [2, 2], [3, 2], [4, 2],
                [0.5, 3], [1.5, 3], [2.5, 3], [3.5, 3],
                [1, 4], [2, 4], [3, 4]
            ],
            adjacentSlots: [
                [1, 3, 4], [0, 2, 4, 5], [1, 5, 6],
                [0, 4, 7, 8], [0, 1, 3, 5, 8, 9], [1, 2, 4, 6, 9, 10], [2, 5, 10, 11],
                [3, 8, 12], [3, 4, 7, 9, 12, 13], [4, 5, 8, 10, 13, 14], [5, 6, 9, 11, 14, 15], [6, 10, 15],
                [7, 8, 13, 16], [8, 9, 12, 14, 16, 17], [9, 10, 13, 15, 17, 18], [10, 11, 14, 18],
                [12, 13, 17], [13, 14, 16, 18], [14, 15, 17]
            ],
            killTarget: 250,
            killsPerLevel: 5,
            levelUpThreshold: 50,
            enemySpawnRatesInitial: [0.3, 0.6, 0, 0.1 ,0],
            midGameRatesCount: 35,
            enemySpawnRatesMidGame: [0.35, 0.35, 0, 0.30, 0],
            finalGameRatesCount: 125,
            enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0],
            bossThresholdInitial: 50,
            bossThresholdIncrement: 30,
            chainDamageMultiplier: 0.8,
            splashDamageMultiplier: 2,
            experiencePerKill: 10,
            experienceChainBonus: 4,
            cardDescriptions: {
                'âš¡ï¸': 'âš¡ï¸ï¼šé›»æ’ƒã€‚éš£æ¥ã™ã‚‹åŒã˜ç¨®é¡ã®æ•µã«é€£é–ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ—¡ï¸': 'ğŸ—¡ï¸ï¼šæ–¬æ’ƒã€‚æ•µã®æœ€å¤§HPã®1/5ã®è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ’¥': 'ğŸ’¥ï¼šçˆ†ç™ºã€‚å‘¨å›²ã®æ•µã®æ•°ã«å¿œã˜ã¦åˆ†æ•£ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚'
            },
            baseDamage: {
                'âš¡ï¸': 10,
                'ğŸ—¡ï¸': 15,
                'ğŸ’¥': 10
            },
            specialCardTypes: ['ğŸ’€', 'ğŸ¦ ', 'ğŸŒŠ'],
            specialCardDescriptions: {
                'ğŸ’€': 'ğŸ’€ï¼šå‘ªç¸›ã€‚å…¨ã¦ã®åŒã˜ç¨®é¡ã®æ•µã«å‘ªç¸›ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ¦ ': 'ğŸ¦ ï¼šæ„ŸæŸ“ã€‚éš£æ¥ã™ã‚‹æ•µã‚’åŒåŒ–ã•ã›æ„ŸæŸ“ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸŒŠ': 'ğŸŒŠï¼šæ´¥æ³¢ã€‚å…¨ã¦ã®æ•µã«æ´¥æ³¢ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚'
            },
            specialCardBaseDamage: {
                'ğŸ’€': 20,
                'ğŸ¦ ': 2,
                'ğŸŒŠ': 10
            }
        };

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
        const gameState = {
            hand: [],
            board: [],
            selectedCardIndex: null,
            selectedSpecialCardIndex: null,
            killCount: 0,
            gameOver: false,
            handSelectionEnabled: true,
            playerLevel: 1,
            playerXp: 0,
            expAdded: 0,
            levelUpThreshold: gameSettings.levelUpThreshold,
            enemySpawnRates: [...gameSettings.enemySpawnRatesInitial],
            isMidGameRatesActive: false,
            isFinalGameRatesActive: false,
            forcePurpleEnemy: false,
            forcePurpleEnemyCount: gameSettings.bossThresholdInitial,
            forcePurpleEnemyThreshold: gameSettings.bossThresholdIncrement,
            bossExtraHpTimes: 0,
            turn: 1,
            specialHand: [null, null],
            specialCardChargeCounter: 0,
            specialCardChargeThreshold: 300,
            emptySlotsPreviousTurn: [],
            emptySlotsCurrentTurn: []
        };

        // DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const domElements = {
            handContainer: document.getElementById('hand-container'),
            specialHandContainer: document.getElementById('special-hand-container'),
            boardContainer: document.getElementById('board-container'),
            messageBox: document.getElementById('message-box'),
            killCountDisplay: document.getElementById('kill-count'),
            cardDescription: document.getElementById('card-description'),
            gameExplanation: document.getElementById('game-explanation'),
            handSlots: null,
            boardSlots: null,
            specialHandSlots: null,
        };

        // ã‚²ãƒ¼ãƒ ã®èª¬æ˜æ–‡
        const explanationText = `ã€ãƒ˜ãƒƒã‚¯ã‚¹ã‚°ãƒªãƒƒãƒ‰ãƒãƒˆãƒ«ã€‘

**ç›®æ¨™**
ã€€æ•µã‚’åˆè¨ˆ${gameSettings.killTarget}ä½“å€’ã™ã¨ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã§ã™ï¼

**ã‚²ãƒ¼ãƒ ã®åŸºæœ¬çš„ãªæµã‚Œ**
1.  **ã‚¿ãƒ¼ãƒ³é–‹å§‹**: å‰ã®ã‚¿ãƒ¼ãƒ³ã«ç©ºã«ãªã£ãŸãƒã‚¹ã«æ•µãŒè£œå……ã•ã‚Œã¾ã™ã€‚
2.  **ã‚«ãƒ¼ãƒ‰é¸æŠ**: æ‰‹æœ­ã‹ã‚‰æ”»æ’ƒã«ä½¿ã„ãŸã„ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã³ã¾ã™ã€‚
3.  **æ”»æ’ƒå¯¾è±¡é¸æŠ**: ãƒœãƒ¼ãƒ‰ä¸Šã®æ•µãŒã„ã‚‹ãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ”»æ’ƒã—ã¾ã™ã€‚
4.  **æ”»æ’ƒå®Ÿè¡Œ**: é¸ã‚“ã ã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã§æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚æ•µã®HPãŒ0ã«ãªã‚‹ã¨å€’ã•ã‚Œã¾ã™ã€‚
5.  **ã‚«ãƒ¼ãƒ‰è£œå……ã¨æˆé•·**: æ•µã‚’å€’ã™ã¨æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è£œå……ã•ã‚Œã¾ã™ã€‚
ã€€ã€€å€’ã—ãŸæ•µã®æ•°ã«å¿œã˜ã¦çµŒé¨“å€¤ãŒå¾—ã‚‰ã‚Œã€çµŒé¨“å€¤ãŒ${gameSettings.levelUpThreshold}ã”ã¨ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¬ãƒ™ãƒ«ã¨æ”»æ’ƒåŠ›ãŒä¸ŠãŒã‚Šã¾ã™ã€‚
ã€€ã€€æ•µã‚’åŒæ™‚ã«å€’ã™ã¨çµŒé¨“å€¤ãƒœãƒ¼ãƒŠã‚¹ï¼

**ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã¨åŠ¹æœ**
* **é€šå¸¸ã‚«ãƒ¼ãƒ‰**:
    * âš¡ï¸ (é›»æ’ƒ)ï¼šéš£æ¥ã™ã‚‹åŒã˜ç¨®é¡ã®æ•µã«é€£é–ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ—¡ï¸ (æ–¬æ’ƒ)ï¼šæ•µã®æœ€å¤§HPã®1/5ã®è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ’¥ (çˆ†ç™º)ï¼šå‘¨å›²ã®æ•µã®æ•°ã«å¿œã˜ã¦åˆ†æ•£ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
* **ã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚«ãƒ¼ãƒ‰**: çµŒé¨“å€¤ã‚’ç²å¾—ã™ã‚‹ã“ã¨ã§ãƒãƒ£ãƒ¼ã‚¸ã•ã‚Œã€æ‰‹æœ­ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚
    * ğŸ’€ (å‘ªç¸›)ï¼šå…¨ã¦ã®åŒã˜ç¨®é¡ã®æ•µã«å‘ªç¸›ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ¦  (æ„ŸæŸ“)ï¼šéš£æ¥ã™ã‚‹æ•µã‚’åŒã˜ç¨®é¡ã«å¤‰åŒ–ã•ã›æ„ŸæŸ“ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸŒŠ (æ´¥æ³¢)ï¼šå…¨ã¦ã®æ•µã«æ´¥æ³¢ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚

**æ•µã«ã¤ã„ã¦**
ã€€æ•µã«ã¯ğŸ”¥ã€ğŸ’§ã€â˜€ï¸ã€ğŸŒ±ã€ğŸ‘¿ã®5ç¨®é¡ãŒã„ã¾ã™ã€‚
ã€€æ•µã¯å€’ã™ã”ã¨ã«å¼·ããªã£ã¦è£œå……ã•ã‚Œã¾ã™ã€‚
ã€€ç‰¹å®šã®è¨ä¼æ•°ã«é”ã™ã‚‹ã¨ã€ã‚ˆã‚Šå¼·åŠ›ãªãƒœã‚¹æ•µï¼ˆğŸ‘¿ï¼‰ãŒå¼·åˆ¶çš„ã«å‡ºç¾ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

**ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼**
ã€€æ‰‹æœ­ãŒå…¨ã¦ãªããªã‚‹ã¨ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¨ãªã‚Šã¾ã™ã€‚
`;

        // åˆæœŸåŒ–
        function initializeGame() {
            gameState.hand = [];
            gameState.board = [];
            gameState.selectedCardIndex = null;
            gameState.selectedSpecialCardIndex = null;
            gameState.killCount = 0;
            gameState.gameOver = false;
            gameState.handSelectionEnabled = true;
            gameState.playerLevel = 1;
            gameState.playerXp = 0;
            gameState.expAdded = 0;
            gameState.levelUpThreshold = gameSettings.levelUpThreshold;
            gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesInitial];
            gameState.isMidGameRatesActive = false;
            gameState.isFinalGameRatesActive = false;
            gameState.forcePurpleEnemy = false;
            gameState.forcePurpleEnemyCount = gameSettings.bossThresholdInitial;
            gameState.bossExtraHpTimes = 0;
            gameState.emptySlotsPreviousTurn = [];
            gameState.emptySlotsCurrentTurn = [];

            domElements.gameExplanation.textContent = explanationText;
            updateMessageBoxUI('ã‚²ãƒ¼ãƒ é–‹å§‹');
            updateKillCountUI();

            for (let i = 0; i < gameSettings.initialHandSize; i++) {
                drawCard();
            }

            for (let i = 0; i < gameSettings.boardSize; i++) {
                spawnEnemy(i);
            }

            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            domElements.boardSlots = document.querySelectorAll('#board-container .hex-cell');
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            domElements.handContainer.addEventListener('click', handleHandClick);
            domElements.boardContainer.addEventListener('click', handleBoardClick);
            domElements.specialHandContainer.addEventListener('click', handleSpecialHandClick);

            // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®æ•µè£œå…… (å‰ã®ã‚¿ãƒ¼ãƒ³ã¯å­˜åœ¨ã—ãªã„ã®ã§ç©º)
            replenishEnemies();

            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            updateMessageBoxUI('æ‰‹æœ­ã‚’é¸æŠã—ã¦ãã ã•ã„');

            // åˆæœŸçŠ¶æ…‹ã®ç©ºã‚»ãƒ«ã‚’è¨˜éŒ² (æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ãŸã‚ã«)
            recordCurrentEmptySlots();
        }

        // æ•µã‚’è£œå……ã™ã‚‹é–¢æ•°
        function replenishEnemies() {
            gameState.emptySlotsPreviousTurn.forEach(emptySlotIndex => {
                if (!gameState.board[emptySlotIndex] || gameState.board[emptySlotIndex].empty) {
                    spawnEnemy(emptySlotIndex);
                }
            });
            gameState.emptySlotsPreviousTurn = []; // ãƒªã‚»ãƒƒãƒˆ
            updateBoardUI();
        }

        // ç¾åœ¨ã®ç©ºã‚»ãƒ«ã‚’è¨˜éŒ²ã™ã‚‹é–¢æ•°
        function recordCurrentEmptySlots() {
            gameState.emptySlotsCurrentTurn = gameState.board.reduce((acc, cell, index) => {
                if (!cell || cell.empty) {
                    acc.push(index);
                }
                return acc;
            }, []);
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã
        function drawCard() {
            if (gameState.hand.length < 5) {
                const randomCardType = gameSettings.cardTypes[Math.floor(Math.random() * gameSettings.cardTypes.length)];
                gameState.hand.push(randomCardType);
            }
        }

        // æ•µã‚’ç”Ÿæˆã™ã‚‹
        function spawnEnemy(slotIndex) {
            const enemyType = generateEnemyType();

            if (generateEnemyType != 'ğŸ‘¿'){
                gameState.bossExtraHpTimes = 0;
            } else {
                gameState.bossExtraHpTimes = 1;
            }
            const newHp = gameSettings.enemyHpValues[enemyType] + Math.floor(gameState.killCount / 5) * 3 + gameState.playerLevel * gameState.bossExtraHpTimes;
            gameState.board[slotIndex] = {
                enemy: {
                    type: enemyType,
                    hp: newHp,
                    maxHp: newHp
                },
                empty: false
            };
        }

        // æ‰‹æœ­ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleHandClick(event) {
            if (!gameState.handSelectionEnabled || gameState.gameOver) return;
            const cardElement = event.target.closest('.card');
            if (cardElement) {
                const cardIndex = parseInt(cardElement.dataset.cardIndex);
                if (gameState.hand[cardIndex] !== undefined) {
                    selectCard(cardIndex);
                }
            }
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleBoardClick(event) {
            if (gameState.selectedCardIndex === null && gameState.selectedSpecialCardIndex === null || gameState.gameOver) return;
            const hexCell = event.target.closest('.hex-cell');
            if (hexCell) {
                const slotIndex = parseInt(hexCell.dataset.slotIndex);
                attack(slotIndex);
            }
        }

        // ç‰¹åˆ¥ãªæ‰‹æœ­ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleSpecialHandClick(event) {
            if (gameState.gameOver) return;
            const cardElement = event.target.closest('.special-card');
            if (cardElement) {
                const cardIndex = parseInt(cardElement.dataset.specialCardIndex);
                if (gameState.specialHand[cardIndex]) {
                    selectCard(cardIndex + 5); // é€šå¸¸ã®æ‰‹æœ­é¸æŠã¨åŒã˜é–¢æ•°ã‚’ä½¿ç”¨
                }
            }
        }

        function updateHandUI() {
            domElements.handContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.cardIndex = i;

                if (gameState.hand[i] !== undefined) { // gameState.hand[i] ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
                    card.textContent = gameState.hand[i];
                    if (gameState.handSelectionEnabled) {
                        card.classList.add('cursor-pointer');
                        card.classList.remove('opacity-50', 'cursor-not-allowed');
                        card.addEventListener('click', handleCardClick); // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å€‹ã€…ã®ã‚«ãƒ¼ãƒ‰ã«è¨­å®š
                    } else {
                        card.classList.add('opacity-50', 'cursor-not-allowed', 'cursor-default');
                        card.removeEventListener('click', handleCardClick);
                    }
                    if (gameState.selectedCardIndex === i) {
                        card.classList.add('selected');
                    }
                } else {
                    card.classList.add('opacity-30', 'cursor-not-allowed');
                    card.textContent = '';
                }
                domElements.handContainer.appendChild(card);
            }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            updateCardDescriptionUI();
        }

        // å€‹ã€…ã®ã‚«ãƒ¼ãƒ‰ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function handleCardClick(event) {
            if (!gameState.handSelectionEnabled || gameState.gameOver) return;
            const cardElement = event.target.closest('.card');
            if (cardElement && !cardElement.classList.contains('opacity-30')) {
                const cardIndex = parseInt(cardElement.dataset.cardIndex);
                // ã“ã“ã§ gameState.hand[cardIndex] ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèª
                if (gameState.hand[cardIndex] !== undefined) {
                    selectCard(cardIndex);
                }
                // æœ‰åŠ¹ãªã‚«ãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°ã€ä½•ã‚‚ã—ãªã„
            }
        }

        function updateSpecialHandUI() {
            // æ–°ã—ã„specialHandSlotsã‚’å–å¾—ã—ç›´ã™
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');

            // å¸¸ã«2ã¤ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’å‡¦ç†
            for (let i = 0; i < 2; i++) {
                const card = domElements.specialHandSlots[i]; // HTMLã§å®šç¾©æ¸ˆã¿ã®ã‚¹ãƒ­ãƒƒãƒˆã‚’å–å¾—
                card.classList.remove('selected', 'opacity-30', 'cursor-not-allowed', 'cursor-pointer'); // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ

                if (gameState.specialHand[i]) { // gameState.specialHand[i] ãŒnullã§ãªã„ã‹ç¢ºèª
                    card.textContent = gameState.specialHand[i];
                    // ç‰¹åˆ¥ãªã‚«ãƒ¼ãƒ‰å›ºæœ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ã—ãŸã„å ´åˆã¯ã“ã“
                    card.classList.add('cursor-pointer'); // ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«ã™ã‚‹
                } else {
                    card.classList.add('opacity-30', 'cursor-not-allowed'); // ç©ºã®å ´åˆã¯åŠé€æ˜ã§ã‚¯ãƒªãƒƒã‚¯ä¸å¯
                    card.textContent = ''; // ç©ºã®ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦è¡¨ç¤º
                }

                // é¸æŠçŠ¶æ…‹ã®ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
                if (gameState.selectedSpecialCardIndex === i) {
                    card.classList.add('selected');
                }

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯åˆæœŸåŒ–æ™‚ã«ã¾ã¨ã‚ã¦è¨­å®šæ¸ˆã¿ã®ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ãƒ»å‰Šé™¤ã—ãªã„
            }
            updateCardDescriptionUI();
        }

        function handleSpecialCardClick(event) {
            if (gameState.gameOver) return;
            const cardElement = event.target.closest('.special-card');
            if (cardElement && !cardElement.classList.contains('opacity-30')) {
                const cardIndex = parseInt(cardElement.dataset.specialCardIndex);
                if (gameState.specialHand[cardIndex]) {
                    selectSpecialCard(cardIndex);
                }
            }
        }


        // ãƒœãƒ¼ãƒ‰ã®è¡¨ç¤ºã‚’æ›´æ–°
        function updateBoardUI() {
            domElements.boardContainer.querySelectorAll('.hex-cell').forEach((cell) => {
                const slotIndex = parseInt(cell.dataset.slotIndex);
                const cellInner = cell.querySelector('.hex-inner');
                cellInner.className = 'hex-inner'; // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ

                if (gameState.board[slotIndex] && !gameState.board[slotIndex].empty) {
                    const enemy = gameState.board[slotIndex].enemy;
                    cellInner.textContent = enemy.type;
                    cellInner.innerHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%; background-color: ${enemy.hp <= enemy.maxHp / 2 ? 'red' : enemy.hp <= enemy.maxHp * 0.75 ? 'yellow' : 'green'};"></div><span class="hp-text">${enemy.hp}</span></div>`;
                    switch (enemy.type) {
                        case 'ğŸ”¥': cellInner.classList.add('bg-red-500'); break;
                        case 'ğŸ’§': cellInner.classList.add('bg-blue-500'); break;
                        case 'â˜€ï¸': cellInner.classList.add('bg-yellow-500'); break;
                        case 'ğŸŒ±': cellInner.classList.add('bg-green-500'); break;
                        case 'ğŸ‘¿': cellInner.classList.add('bg-purple-500'); break;
                    }
                } else {
                    cellInner.classList.add('bg-gray-400');
                    cellInner.textContent = 'Empty';
                }
            });
        }

        // å€’ã—ãŸæ•µã®æ•°ã‚’æ›´æ–°
        function updateKillCountUI() {
            domElements.killCountDisplay.textContent = `å€’ã—ãŸæ•µã®æ•°: ${gameState.killCount}/${gameSettings.killTarget}\nLv: ${gameState.playerLevel}\nExp: ${gameState.playerXp} ã€€(+ ${gameState.expAdded})`;
            gameState.expAdded = 0;
        }

        // ã‚«ãƒ¼ãƒ‰ã®èª¬æ˜ã‚’æ›´æ–°
        function updateCardDescriptionUI() {
            let description = 'é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã‚’è¡¨ç¤º';
            let damageText = '';

            if (gameState.selectedCardIndex !== null) {
                const cardType = gameState.hand[gameState.selectedCardIndex];
                description = gameSettings.cardDescriptions[cardType] || description;
                const baseDamage = gameSettings.baseDamage[cardType] || 0;
                damageText = `<span class="damage-text">åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸: ${baseDamage + gameState.playerLevel}</span>`;
            } else if (gameState.selectedSpecialCardIndex !== null) {
                const cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                description = gameSettings.specialCardDescriptions[cardType] || description;
                const baseDamage = gameSettings.specialCardBaseDamage[cardType] || 0;
                damageText = `<span class="damage-text">åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸: ${baseDamage + gameState.playerLevel}</span>`;
            } else {
                damageText = '';
            }

            domElements.cardDescription.innerHTML = `${description}<br>${damageText}`;
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã®æ›´æ–°
        function updateMessageBoxUI(message) {
            domElements.messageBox.textContent = message;
        }

        // ã‚«ãƒ¼ãƒ‰ã®é¸æŠ
        function selectCard(index) {
            if (gameState.gameOver || !gameState.handSelectionEnabled) return;

            // é¸æŠçŠ¶æ…‹ã‚’ä¸Šæ›¸ã
            if (index >= 0 && index < 5) {
                gameState.selectedCardIndex = index;
                gameState.selectedSpecialCardIndex = null;
            } else {
                gameState.selectedSpecialCardIndex = index - 5; // ç‰¹åˆ¥ãªæ‰‹æœ­ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´
                gameState.selectedCardIndex = null;
            }

            updateHandUI();
            updateSpecialHandUI();
            updateCardDescriptionUI();
            updateMessageBoxUI('æ”»æ’ƒã™ã‚‹ãƒã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„');
        }

        // ç‰¹åˆ¥ãªã‚«ãƒ¼ãƒ‰ã®é¸æŠ
        function selectSpecialCard(index) {
            if (gameState.gameOver) return;
            gameState.selectedCardIndex = null; // é€šå¸¸ã®æ‰‹æœ­ã®é¸æŠã‚’è§£é™¤
            gameState.selectedSpecialCardIndex = index;
            updateHandUI();
            updateSpecialHandUI();
            updateCardDescriptionUI();
            updateMessageBoxUI('æ”»æ’ƒã™ã‚‹ãƒã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„');
        }

        // æ”»æ’ƒ
        function attack(slotIndex) {
            if (gameState.gameOver) return;

            let cardType = null;
            let baseDamage = 0;
            let selectedIndex = null;

            if (gameState.selectedCardIndex !== null) {
                cardType = gameState.hand[gameState.selectedCardIndex];
                baseDamage = gameSettings.baseDamage[cardType] + gameState.playerLevel;
                selectedIndex = gameState.selectedCardIndex;
                
            } else if (gameState.selectedSpecialCardIndex !== null) {
                cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                baseDamage = gameSettings.specialCardBaseDamage[cardType] + gameState.playerLevel;
                selectedIndex = gameState.selectedSpecialCardIndex;
                
            } else {
                updateMessageBoxUI('æ‰‹æœ­ã‚’å…ˆã«é¸ã‚“ã§ãã ã•ã„');
                return;
            }

            if (!gameState.board[slotIndex] || gameState.board[slotIndex].empty) {
                updateMessageBoxUI('ç©ºã®ãƒã‚¹ã«ã¯æ”»æ’ƒã§ãã¾ã›ã‚“');
                return;
            }

            let enemiesKilled = 0;
            const attackedSlot = gameState.board[slotIndex];
            let damage = baseDamage; // åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä»£å…¥

            switch (cardType) {
                case 'âš¡ï¸': {
                        const queue = [slotIndex];
                        const damagedSlots = new Set();
                        damagedSlots.add(slotIndex);
                        attackedSlot.enemy.hp -= damage;
                        if (attackedSlot.enemy.hp <= 0) {
                            attackedSlot.empty = true;
                            enemiesKilled++;
                            handleBossSpawn();
                        }

                        while (queue.length > 0) {
                            const currentSlotIndex = queue.shift();
                            const adjacentSlots = gameSettings.adjacentSlots[currentSlotIndex] || [];
                            for (const adjacentSlotIndex of adjacentSlots) {
                                if (gameState.board[adjacentSlotIndex] && !damagedSlots.has(adjacentSlotIndex) && !gameState.board[adjacentSlotIndex].empty && gameState.board[adjacentSlotIndex].enemy.type === attackedSlot.enemy.type) {
                                    damagedSlots.add(adjacentSlotIndex);
                                    const chainDamage = Math.floor(damage * gameSettings.chainDamageMultiplier);
                                    gameState.board[adjacentSlotIndex].enemy.hp -= chainDamage;
                                    if (gameState.board[adjacentSlotIndex].enemy.hp <= 0) {
                                        gameState.board[adjacentSlotIndex].empty = true;
                                        enemiesKilled++;
                                        handleBossSpawn();
                                    }
                                    queue.push(adjacentSlotIndex);
                                }
                            }
                        }

                    break;
                }
                case 'ğŸ—¡ï¸': {
                    damage += Math.floor(attackedSlot.enemy.maxHp / 5);
                    // å…±é€šå‡¦ç†ã§ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
                    break;
                }
                case 'ğŸ’¥': {
                        const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                        const adjacentEnemies = adjacentSlots.filter(index => gameState.board[index] && !gameState.board[index].empty);
                        const splashDamage = adjacentEnemies.length > 0 ? Math.floor((damage * gameSettings.splashDamageMultiplier) / adjacentEnemies.length) : 0;
                        adjacentEnemies.forEach(adjacentSlotIndex => {
                            gameState.board[adjacentSlotIndex].enemy.hp -= splashDamage;
                            if (gameState.board[adjacentSlotIndex].enemy.hp <= 0) {
                                gameState.board[adjacentSlotIndex].empty = true;
                                enemiesKilled++;
                                handleBossSpawn();
                            }
                        });
                    break;
                }
                case 'ğŸ’€': {
                        const targetEnemyType = attackedSlot.enemy.type;
                        gameState.board.forEach(cell => {
                            if (cell && !cell.empty && cell.enemy.type === targetEnemyType) {
                                cell.enemy.hp -= baseDamage;
                                if (cell.enemy.hp <= 0) {
                                    cell.empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                    break;
                }
                case 'ğŸ¦ ': {
                        const targetEnemyType = attackedSlot.enemy.type;
                        const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                        adjacentSlots.forEach(adjIndex => {
                            if (gameState.board[adjIndex] && !gameState.board[adjIndex].empty) {
                                gameState.board[adjIndex].enemy.type = targetEnemyType;
                                gameState.board[adjIndex].enemy.hp -= baseDamage;
                                if (gameState.board[adjIndex].enemy.hp <= 0) {
                                    gameState.board[adjIndex].empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                        attackedSlot.enemy.hp -= baseDamage; // é¸æŠã—ãŸæ•µã«ã‚‚æ„ŸæŸ“ãƒ€ãƒ¡ãƒ¼ã‚¸
                        if (attackedSlot.enemy.hp <= 0) {
                            attackedSlot.empty = true;
                            enemiesKilled++;
                            handleBossSpawn();
                        }
                    break;
                }
                case 'ğŸŒŠ': {
                        gameState.board.forEach(cell => {
                            if (cell && !cell.empty) {
                                cell.enemy.hp -= baseDamage;
                                if (cell.enemy.hp <= 0) {
                                    cell.empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                    break;
                }
            }

            // å…±é€šãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨å‡¦ç†
            if (cardType !== 'âš¡ï¸' && cardType !== 'ğŸ’€' && cardType !== 'ğŸŒŠ') { // å…¨ä½“æ”»æ’ƒã¯å€‹åˆ¥å‡¦ç†
                attackedSlot.enemy.hp -= damage;
                if (attackedSlot.enemy.hp <= 0) {
                    attackedSlot.empty = true;
                    enemiesKilled++;
                    handleBossSpawn();
                }
            }

            updateMessageBoxUI('æ”»æ’ƒï¼');

            // ä½¿ç”¨ã—ãŸã‚«ãƒ¼ãƒ‰ã‚’ç©ºã«ã™ã‚‹
            if (selectedIndex !== null) {
                if (gameState.selectedCardIndex !== null) {

                    gameState.hand[gameState.selectedCardIndex] = undefined;
                    gameState.hand = gameState.hand.filter(card => card !== undefined);
                   
                    //console.log(gameState.specialHand);
                } else if (gameState.selectedSpecialCardIndex !== null) {
                    gameState.specialHand[gameState.selectedSpecialCardIndex] = null;
                    // 3ã¤ç›®ä»¥é™ã®è¦ç´ ã‚’å‰Šé™¤
                    /*if (gameState.specialHand.length > 2) {
                        gameState.specialHand.length = 2;
                    }*/
                   console.log(gameState.specialHand);
                }
            }

                gameState.selectedCardIndex = null;
                gameState.selectedSpecialCardIndex = null;
                gameState.handSelectionEnabled = false; // é¸æŠç„¡åŠ¹åŒ–

                // ã‚«ãƒ¼ãƒ‰ã« 'disabled' ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                domElements.handSlots.forEach(card => {
                    if (!card.classList.contains('opacity-30')) { // ç©ºã®ã‚«ãƒ¼ãƒ‰ã§ãªã‘ã‚Œã°
                        card.classList.add('disabled');
                    }
                });
                domElements.specialHandSlots.forEach(card => {
                    if (!card.classList.contains('opacity-30')) {
                        card.classList.add('disabled');
                    }
                });

            gameState.killCount += enemiesKilled;
            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            handleExperience(enemiesKilled);
            updateKillCountUI();

            setTimeout(() => {
                // å€’ã—ãŸæ•µã®æ•°ã«å¿œã˜ã¦ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã
                const cardsToDraw = Math.min(enemiesKilled, 5 - gameState.hand.length);
                for (let i = 0; i < cardsToDraw; i++) {
                    drawCard();
                }

                // ç¾åœ¨ã®ç©ºã‚»ãƒ«æƒ…å ±ã‚’è¨˜éŒ²
                recordCurrentEmptySlots();

                // ãƒœãƒ¼ãƒ‰ãŒå®Œå…¨ã«ç©ºã«ãªã£ãŸã‹ã‚’ãƒã‚§ãƒƒã‚¯
                const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);
                if (isBoardCompletelyEmpty) {
                    // å…¨ã¦ã®ãƒã‚¹ã‚’è£œå……å¯¾è±¡ã¨ã™ã‚‹
                    gameState.emptySlotsPreviousTurn = Array.from({ length: gameSettings.boardSize }, (_, i) => i);
                } else {
                    // å‰ã®ã‚¿ãƒ¼ãƒ³ã«ç©ºã ã£ãŸã‚»ãƒ«ã«æ•µã‚’è£œå……
                    replenishEnemies();
                }
                //gameState.emptySlotsCurrentTurn = []; // ç¾åœ¨ã®ç©ºã‚»ãƒ«æƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ

                gameState.handSelectionEnabled = true; // é¸æŠã‚’å†ã³æœ‰åŠ¹åŒ–

                // 'disabled' ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
                domElements.handSlots.forEach(card => {
                    card.classList.remove('disabled');
                });
                domElements.specialHandSlots.forEach(card => {
                    card.classList.remove('disabled');
                });

                updateHandUI();
                updateSpecialHandUI();
                updateBoardUI();

                // ã‚¿ãƒ¼ãƒ³ã®æœ€å¾Œã«ã€ç¾åœ¨ã®ç©ºã‚»ãƒ«æƒ…å ±ã‚’å‰ã®ã‚¿ãƒ¼ãƒ³ã®æƒ…å ±ã«ç§»ã™
                gameState.emptySlotsPreviousTurn = [...gameState.emptySlotsCurrentTurn];
                gameState.emptySlotsCurrentTurn = [];

                updateMessageBoxUI('æ‰‹æœ­ã‚’é¸æŠã—ã¦ãã ã•ã„');
                
                if (gameState.killCount >= gameSettings.killTarget) {
                    gameState.gameOver = true;
                    updateMessageBoxUI('ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼');
                    domElements.messageBox.classList.add('message-box-clear');
                    endGame();
                }

                if (gameState.hand.length === 0 && gameState.specialHand.every(card => card === null) && gameState.board.some(cell => cell && !cell.empty)) {
                gameState.gameOver = true;
                updateMessageBoxUI('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼šæ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“');
                domElements.messageBox.classList.add('message-box-gameover');
                endGame();
                return;
                }

            }, 400);

            gameState.handSelectionEnabled = true;
        }


        // ãƒœã‚¹å‡ºç¾ã®åˆ¤å®š
        function handleBossSpawn() {
            if (gameState.killCount >= gameState.forcePurpleEnemyCount) {
                gameState.forcePurpleEnemy = true;
                gameState.forcePurpleEnemyCount += gameState.forcePurpleEnemyThreshold;
            }
        }

        // æ•µã®ç¨®é¡ã®ç”Ÿæˆ
        function generateEnemyType() {
            if (gameState.forcePurpleEnemy) {
                gameState.forcePurpleEnemy = false;
                return 'ğŸ‘¿';
            } else {
                let rand = Math.random();
                let cumulativeProbability = 0;
                for (let i = 0; i < gameState.enemySpawnRates.length; i++) {
                    cumulativeProbability += gameState.enemySpawnRates[i];
                    if (rand < cumulativeProbability) {
                        return gameSettings.enemyTypes[i];
                    }
                }
                return gameSettings.enemyTypes[gameSettings.enemyTypes.length - 1];
            }
        }

        // çµŒé¨“å€¤ã®å‡¦ç†
        function handleExperience(enemiesKilled) {
            gameState.expAdded = (enemiesKilled * gameSettings.experiencePerKill) + (enemiesKilled > 0 ? (enemiesKilled - 1) * gameSettings.experienceChainBonus : 0);
            gameState.playerXp += gameState.expAdded;
            gameState.specialCardChargeCounter += gameState.expAdded; // ç‰¹åˆ¥ãªã‚«ãƒ¼ãƒ‰ã®ãƒãƒ£ãƒ¼ã‚¸

            // æ•µã®æŠ½é¸ç¢ºç‡ã‚’å¤‰æ›´
            if (gameState.killCount >= gameSettings.midGameRatesCount && !gameState.isMidGameRatesActive) {
            gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesMidGame];
            gameState.isMidGameRatesActive = true;
            } else if (gameState.killCount >= gameSettings.finalGameRatesCount && !gameState.isFinalGameRatesActive) {
            gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesFinalGame];
            gameState.isFinalGameRatesActive = true;
            }

            while (gameState.playerXp >= gameState.levelUpThreshold) {
                gameState.playerLevel++;
                gameState.levelUpThreshold += gameSettings.levelUpThreshold;
            }

            // ç‰¹åˆ¥ãªã‚«ãƒ¼ãƒ‰ã®è£œå……
            while (gameState.specialCardChargeCounter >= gameState.specialCardChargeThreshold) {
                gameState.specialCardChargeThreshold += gameState.specialCardChargeThreshold;
                addSpecialCardToHand();
                updateSpecialHandUI();
            }
        }

        function addSpecialCardToHand() {
            const emptySlotIndex = gameState.specialHand.findIndex(card => card === null);
            if (emptySlotIndex !== -1) {
                const randomCardType = gameSettings.specialCardTypes[Math.floor(Math.random() * gameSettings.specialCardTypes.length)];
                gameState.specialHand[emptySlotIndex] = randomCardType;
            }
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†
        function endGame() {
            domElements.handContainer.removeEventListener('click', handleHandClick);
            domElements.boardContainer.removeEventListener('click', handleBoardClick);
            domElements.specialHandContainer.removeEventListener('click', handleSpecialHandClick);

            domElements.handContainer.classList.add('disabled-overlay');
            domElements.boardContainer.classList.add('disabled-overlay');
            domElements.specialHandContainer.classList.add('disabled-overlay');
            domElements.messageBox.classList.add('message-box-clear');
        }

        // ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
        initializeGame();
    </script>
</body>
</html>
