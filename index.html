<!DOCTYPE html>
<html>
<head>
    <title>ãƒ˜ãƒƒã‚¯ã‚¹ã‚°ãƒªãƒƒãƒ‰ãƒãƒˆãƒ«</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {font-family: 'Arial', sans-serif;margin: 0;padding: 0;background-color: #111827;color: #f9fafb;display: flex;justify-content: center;align-items: center;min-height: 100vh;background-size: cover;background-position: center;flex-direction: column;}
        #game-container {display: flex;flex-direction: row;align-items: center;padding: 1.25rem;max-width: 100%;width: 100%;box-sizing: border-box;}
        #board-container {display: flex;flex-direction: column;align-items: center;margin-bottom: 0.75rem;width: 100%;max-width: 600px;margin-right: 2rem;}
        .row {display: flex;justify-content: center;margin-bottom: 0.25rem;width: 100%;}
        .hex-cell {width: 56px;height: 64px;display: flex;justify-content: center;align-items: center;margin: 0 0.25rem;border-radius: 0.5rem;font-size: 0.75rem;position: relative;animation: new-ally-fade-in 0.3s ease-out forwards;}
        .hex-inner {width: 100%;height: 100%;background-color: #4b5563;border-radius: 0.5rem;display: flex;justify-content: center;align-items: center;position: absolute;top: 0;left: 0;border: 2px solid;border-color: #6b7280;}
        .hex-Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ² {background-color: #86ef7d;}
        .hex-Ğ¾ÑĞ»Ğ°Ğ±Ğ»ĞµĞ½ {background-color: #f43f5e;}
        .enemy-Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ² {color: #ffffff;}
        .enemy-Ğ¾ÑĞ»Ğ°Ğ±Ğ»ĞµĞ½ {color: #ffffff;}
        .slot-number {position: absolute;top: 0.15rem;left: 0.25rem;font-size: 0.5rem;color: #cbd5e0;z-index: 10;}
        #message-box {background-color: #17233c;color: #f9fafb;padding: 0.5rem;margin-bottom: 0.75rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 600px;border: 2px solid;border-color: #6b7280;}
        .message-box-clear { background-color: #ffe35a !important; color: #062b08 !important; border-color: #fbaf21 !important; }
        .message-box-gameover { background-color: #aa2ac0 !important; color: #f3ffae !important; border-color: #f398ff !important; }
        #right-container {display: flex;flex-direction: column;align-items: center;margin-left: 2rem;padding-right: 1rem;}
        #card-description {background-color: #101520;color: #f9fafb;height: 4.0rem;padding: 0.5rem;margin-bottom: 2rem;border-radius: 0.5rem;text-align: center;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        #hand-container {display: flex;justify-content: center;margin-bottom: 0.95rem;width: 100%;max-width: 600px;}
        .card {width: 64px;height: 80px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #374151;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.3);}
        .card.selected {background-color: #6b7280;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0.4);}
        .card.disabled {opacity: 0.5;cursor: not-allowed;}
        #top-right-ui {display: flex;flex-direction: row;align-items: center;justify-content: center;margin-bottom: 0.75rem;width: 100%;max-width: 400px;}
        #special-hand-container {display: flex;justify-content: center;align-items: center;margin-left: 0.5rem;margin-bottom: 0.75rem;}
        .special-card {width: 64px;height: 90px;display: flex;justify-content: center;align-items: center;margin: 0 0.5rem;cursor: pointer;border-radius: 0.5rem;box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2);transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;font-size: 1rem;background-color: #6b46c1;color: #f9fafb;border: 2px solid;border-color: #4b5563;}
        .special-card:hover {transform: scale(1.2);box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.3);}
        .special-card.selected {background-color: #7763b1;border-color: #f5f5f5;box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);}
        .special-card.disabled {opacity: 0.5;cursor: not-allowed;}
        #kill-count {background-color: #101520;color: #f9fafb;padding: 0.5rem;border-radius: 0.5rem;text-align: center;margin-right: 0.5rem;margin-left: 0.2rem;margin-bottom: 0.75rem;width: 100%;max-width: 400px;border: 2px solid;border-color: #6b7280;white-space: pre-line;}
        .hp-bar {width: 80%;height: 0.5rem;background-color: #6b7280;border-radius: 0.25rem;margin-top: 0.25rem;position: absolute;bottom: 0.25rem;left: 10%;}
        .hp-fill {height: 100%;background-color: #86ef7d;border-radius: 0.25rem;width: 100%;}
        .hp-text {position: absolute;top: -0.6rem;right: 0.04rem;font-size: 0.7rem;color: #333;z-index: 1;}
        .damage-text {font-size: 0.9rem; }
        #game-explanation { height: 5.7em; overflow-y: auto; border: 2px solid #6b7280; background-color: #201c10; color: #f9fafb; padding: 0.5rem; border-radius: 0.5rem;  white-space: pre-line; text-align: left; margin-bottom: 0.75rem; max-width: 400px; width: 100%; box-sizing: border-box;}
        @keyframes new-ally-fade-in { 0% { opacity: 0.5; transform: scale(0.8); } 100% { opacity: 1; transform: scale(1); } }
        .disabled-overlay { opacity: 0.5; pointer-events: none; }
        
        .hidden { display: none; }
        #modal-overlay { z-index: 40; }
        #modal-content {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            width: 90%;
            max-width: 500px;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-50">
    <div id="game-container" class="flex flex-row items-start">
        <div id="left-container">
            <div id="board-container" class="flex flex-col items-center mb-3">
                <div class="row">
                    <div class="hex-cell" data-slot-index="0"><span class="slot-number">1</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="1"><span class="slot-number">2</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="2"><span class="slot-number">3</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="3"><span class="slot-number">4</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="4"><span class="slot-number">5</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="5"><span class="slot-number">6</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="6"><span class="slot-number">7</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="7"><span class="slot-number">8</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="8"><span class="slot-number">9</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="9"><span class="slot-number">10</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="10"><span class="slot-number">11</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="11"><span class="slot-number">12</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="12"><span class="slot-number">13</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="13"><span class="slot-number">14</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="14"><span class="slot-number">15</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="15"><span class="slot-number">16</span><div class="hex-inner"></div></div>
                </div>
                <div class="row">
                    <div class="hex-cell" data-slot-index="16"><span class="slot-number">17</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="17"><span class="slot-number">18</span><div class="hex-inner"></div></div>
                    <div class="hex-cell" data-slot-index="18"><span class="slot-number">19</span><div class="hex-inner"></div></div>
                </div>
            </div>
            <div id="message-box" class="mb-3 text-center"></div>
        </div>
        <div id="right-container">
            <div id="top-right-ui" class="flex flex-row justify-center mb-3">
                <div id="kill-count" class="text-center mr-2">å€’ã—ãŸæ•µã®æ•°: 0/250<br>Lv: 1<br>Exp: 0/50</div>
                <div id="special-hand-container" class="flex justify-center">
                    <div class="special-card" data-special-card-index="0"></div>
                    <div class="special-card" data-special-card-index="1"></div>
                </div>
            </div>
            <div id="hand-container" class="flex justify-center mb-3">
                <div class="card" data-card-index="0"></div>
                <div class="card" data-card-index="1"></div>
                <div class="card" data-card-index="2"></div>
                <div class="card" data-card-index="3"></div>
                <div class="card" data-card-index="4"></div>
            </div>
            <div id="card-description" class="mb-3 text-center"></div>
            <div id="game-explanation" class="mb-3 text-left overflow-y-auto">
            </div>
        </div>
    </div>

    <div class="mt-4 flex justify-center items-center">
        <button id="reset-button" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded mr-2">ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="settings-button" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">è¨­å®š</button>
        <div class="ml-4 flex space-x-2">
            <div id="difficulty-indicator" class="w-4 h-4 rounded-full transition-colors" title="ç¾åœ¨ã®é›£æ˜“åº¦"></div>
            <div id="endless-mode-indicator" class="w-4 h-4 rounded-full transition-colors" title="ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰"></div>
        </div>
    </div>
    <div id="settings-modal" class="hidden">
        <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 cursor-pointer"></div>
        <div id="modal-content" class="fixed bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-600 text-center">
            <h2 class="text-2xl font-bold mb-6">è¨­å®š</h2>
            
            <div class="mb-5">
                <h3 class="text-lg mb-2">é›£æ˜“åº¦</h3>
                <div class="flex justify-center space-x-2">
                    <button data-difficulty="easy" class="difficulty-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">ã‚¤ãƒ¼ã‚¸ãƒ¼</button>
                    <button data-difficulty="normal" class="difficulty-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">ãƒãƒ¼ãƒãƒ«</button>
                    <button data-difficulty="hard" class="difficulty-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-28 transition-transform duration-200">ãƒãƒ¼ãƒ‰</button>
                    </div>
            </div>

            <div class="mb-8">
                <h3 class="text-lg mb-2">ãƒ¢ãƒ¼ãƒ‰</h3>
                <button id="endless-mode-button" class="w-full bg-purple-800 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors">ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰: OFF</button>
            </div>

            <div class="flex justify-end space-x-4">
                <button id="cancel-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button id="confirm-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">æ±ºå®š</button>
            </div>
        </div>
    </div>
    <script>
// ã‚²ãƒ¼ãƒ è¨­å®š
        const gameSettings = {
            // â–¼â–¼â–¼ å…±é€šè¨­å®š â–¼â–¼â–¼
            initialHandSize: 5,
            boardSize: 19,
            cardTypes: ['âš¡ï¸', 'ğŸ—¡ï¸', 'ğŸ’¥'],
            enemyTypes: ['ğŸ”¥', 'ğŸ’§', 'â˜€ï¸', 'ğŸŒ±', 'ğŸ‘¿'],
            enemyHpValues: {'ğŸ”¥': 15,'ğŸ’§': 8,'â˜€ï¸': 15,'ğŸŒ±': 20,'ğŸ‘¿': 150},
            slotCoordinates: [
                [0, 0], [1, 0], [2, 0],
                [0.5, 1], [1.5, 1], [2.5, 1], [3.5, 1],
                [0, 2], [1, 2], [2, 2], [3, 2], [4, 2],
                [0.5, 3], [1.5, 3], [2.5, 3], [3.5, 3],
                [1, 4], [2, 4], [3, 4]
            ],
            adjacentSlots: [
                [1, 3, 4], [0, 2, 4, 5], [1, 5, 6],
                [0, 4, 7, 8], [0, 1, 3, 5, 8, 9], [1, 2, 4, 6, 9, 10], [2, 5, 10, 11],
                [3, 8, 12], [3, 4, 7, 9, 12, 13], [4, 5, 8, 10, 13, 14], [5, 6, 9, 11, 14, 15], [6, 10, 15],
                [7, 8, 13, 16], [8, 9, 12, 14, 16, 17], [9, 10, 13, 15, 17, 18], [10, 11, 14, 18],
                [12, 13, 17], [13, 14, 16, 18], [14, 15, 17]
            ],
            killsPerLevel: 5,
            levelUpThreshold: 50,
            specialCardChargeThreshold: 400,
            bossThresholdIncrement: 25,
            chainDamageMultiplier: 0.8,
            splashDamageMultiplier: 2,
            experiencePerKill: 10,
            experienceChainBonus: 4,
            cardDescriptions: {
                'âš¡ï¸': 'âš¡ï¸ï¼šé›»æ’ƒã€‚éš£æ¥ã™ã‚‹åŒã˜ç¨®é¡ã®æ•µã«è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ—¡ï¸': 'ğŸ—¡ï¸ï¼šæ–¬æ’ƒã€‚æ•µã®æœ€å¤§HPã®1/5ã®è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ’¥': 'ğŸ’¥ï¼šçˆ†ç™ºã€‚å‘¨å›²ã®æ•µã®æ•°ã«å¿œã˜ã¦è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚'
            },
            baseDamage: {
                'âš¡ï¸': 10,
                'ğŸ—¡ï¸': 15,
                'ğŸ’¥': 10
            },
            specialCardTypes: ['ğŸ’€', 'ğŸ¦ ', 'ğŸŒŠ'],
            specialCardDescriptions: {
                'ğŸ’€': 'ğŸ’€ï¼šå‘ªç¸›ã€‚å…¨ã¦ã®åŒã˜ç¨®é¡ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸ¦ ': 'ğŸ¦ ï¼šæ„ŸæŸ“ã€‚éš£æ¥ã™ã‚‹æ•µã‚’åŒåŒ–ã•ã›ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                'ğŸŒŠ': 'ğŸŒŠï¼šæ´¥æ³¢ã€‚å…¨ã¦ã®æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚'
            },
            specialCardBaseDamage: {
                'ğŸ’€': 20,
                'ğŸ¦ ': 2,
                'ğŸŒŠ': 10
            },
            // â–²â–²â–² å…±é€šè¨­å®š â–²â–²â–²

            // â–¼â–¼â–¼ é›£æ˜“åº¦åˆ¥è¨­å®š â–¼â–¼â–¼
            difficultySettings: {
                easy: {
                    killTarget: 100,
                    enemySpawnRatesInitial: [0.4, 0.6, 0, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.4, 0.5, 0, 0.1, 0],
                    finalGameRatesCount: 80,
                    enemySpawnRatesFinalGame: [0.3, 0.5, 0, 0.2, 0],
                    bossThresholdInitial: 80,
                },
                normal: {
                    killTarget: 150,
                    enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0],
                    finalGameRatesCount: 100,
                    enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0],
                    bossThresholdInitial: 50,
                },
                hard: {
                    killTarget: 250,
                    enemySpawnRatesInitial: [0.4, 0.5, 0.1, 0, 0],
                    midGameRatesCount: 35,
                    enemySpawnRatesMidGame: [0.35, 0.45, 0, 0.2, 0],
                    finalGameRatesCount: 125,
                    enemySpawnRatesFinalGame: [0.25, 0.25, 0.25, 0.25, 0],
                    bossThresholdInitial: 50,
                }
            }
            // â–²â–²â–² é›£æ˜“åº¦åˆ¥è¨­å®š â–²â–²â–²
        };

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
        const gameState = {
            hand: [],
            board: [],
            selectedCardIndex: null,
            selectedSpecialCardIndex: null,
            killCount: 0,
            gameOver: false,
            handSelectionEnabled: true,
            playerLevel: 1,
            playerXp: 0,
            playerXpTotal: 0,
            expForNextLevel: 0,
            expAdded: 0,
            enemySpawnRates: [],
            isMidGameRatesActive: false,
            isFinalGameRatesActive: false,
            forcePurpleEnemy: false,
            forcePurpleEnemyCount: 0,
            forcePurpleEnemyThreshold: 0,
            bossExtraHpTimes: 0,
            turn: 1,
            specialHand: [null, null],
            specialCardChargeCounter: 0,
            specialCardChargeAdd: 400,
            emptySlotsPreviousTurn: [],
            difficulty: 'normal',
            isEndlessMode: false,
            emptySlotsCurrentTurn: []
        };

        // DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const domElements = {
            handContainer: document.getElementById('hand-container'),
            specialHandContainer: document.getElementById('special-hand-container'),
            boardContainer: document.getElementById('board-container'),
            messageBox: document.getElementById('message-box'),
            killCountDisplay: document.getElementById('kill-count'),
            cardDescription: document.getElementById('card-description'),
            gameExplanation: document.getElementById('game-explanation'),
            handSlots: null,
            boardSlots: null,
            specialHandSlots: null,
            difficultyIndicator: document.getElementById('difficulty-indicator'), // â˜…è¿½åŠ 
            endlessModeIndicator: document.getElementById('endless-mode-indicator'), // â˜…è¿½åŠ 
        };

        // é›£æ˜“åº¦è¨­å®šã‚’é©ç”¨ã™ã‚‹é–¢æ•°
        function applyDifficultySettings(difficulty) {
            const newSettings = gameSettings.difficultySettings[difficulty];
            if (newSettings) {
                // gameSettingsã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã«é›£æ˜“åº¦è¨­å®šã‚’ãƒãƒ¼ã‚¸ã™ã‚‹
                Object.assign(gameSettings, newSettings);
            }
        }

        // ã‚²ãƒ¼ãƒ èª¬æ˜æ–‡ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
        function generateExplanationText() {
            return `ã€ãƒ˜ãƒƒã‚¯ã‚¹ã‚°ãƒªãƒƒãƒ‰ãƒãƒˆãƒ«ã€‘

**ç›®æ¨™**
ã€€æ•µã‚’åˆè¨ˆ${gameSettings.killTarget === Infinity ? 'âˆ' : gameSettings.killTarget}ä½“å€’ã™ã¨ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã§ã™ï¼

**ã‚²ãƒ¼ãƒ ã®åŸºæœ¬çš„ãªæµã‚Œ**
1.  **ã‚¿ãƒ¼ãƒ³é–‹å§‹**: å‰ã®ã‚¿ãƒ¼ãƒ³ã«ç©ºã«ãªã£ãŸãƒã‚¹ã«æ•µãŒè£œå……ã•ã‚Œã¾ã™ã€‚
2.  **ã‚«ãƒ¼ãƒ‰é¸æŠ**: æ‰‹æœ­ã‹ã‚‰æ”»æ’ƒã«ä½¿ã„ãŸã„ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã³ã¾ã™ã€‚
3.  **æ”»æ’ƒå¯¾è±¡é¸æŠ**: ãƒœãƒ¼ãƒ‰ä¸Šã®æ•µãŒã„ã‚‹ãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ”»æ’ƒã—ã¾ã™ã€‚
4.  **æ”»æ’ƒå®Ÿè¡Œ**: é¸ã‚“ã ã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã§æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚æ•µã®HPãŒ0ã«ãªã‚‹ã¨å€’ã•ã‚Œã¾ã™ã€‚
5.  **ã‚«ãƒ¼ãƒ‰è£œå……ã¨æˆé•·**: æ•µã‚’å€’ã™ã¨æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ãŒæ‰‹æœ­ã«è£œå……ã•ã‚Œã¾ã™ã€‚
ã€€ã€€å€’ã—ãŸæ•µã®æ•°ã«å¿œã˜ã¦çµŒé¨“å€¤ãŒå¾—ã‚‰ã‚Œã€ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã™ã‚‹ã¨æ”»æ’ƒåŠ›ãŒä¸ŠãŒã‚Šã¾ã™ã€‚
ã€€ã€€æ•µã‚’åŒæ™‚ã«å€’ã™ã¨çµŒé¨“å€¤ãƒœãƒ¼ãƒŠã‚¹ï¼

**ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡ã¨åŠ¹æœ**
* **é€šå¸¸ã‚«ãƒ¼ãƒ‰**:
    * âš¡ï¸ (é›»æ’ƒ)ï¼šéš£æ¥ã™ã‚‹åŒã˜ç¨®é¡ã®æ•µã«é€£é–ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ—¡ï¸ (æ–¬æ’ƒ)ï¼šæ•µã®æœ€å¤§HPã®1/5ã®è¿½åŠ ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ’¥ (çˆ†ç™º)ï¼šå‘¨å›²ã®æ•µã®æ•°ã«å¿œã˜ã¦åˆ†æ•£ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
* **ã‚¹ãƒšã‚·ãƒ£ãƒ«ã‚«ãƒ¼ãƒ‰**: çµŒé¨“å€¤ã‚’ç²å¾—ã™ã‚‹ã“ã¨ã§ãƒãƒ£ãƒ¼ã‚¸ã•ã‚Œã€æ‰‹æœ­ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚
    * ğŸ’€ (å‘ªç¸›)ï¼šå…¨ã¦ã®åŒã˜ç¨®é¡ã®æ•µã«å‘ªç¸›ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸ¦  (æ„ŸæŸ“)ï¼šéš£æ¥ã™ã‚‹æ•µã‚’åŒã˜ç¨®é¡ã«å¤‰åŒ–ã•ã›æ„ŸæŸ“ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚
    * ğŸŒŠ (æ´¥æ³¢)ï¼šå…¨ã¦ã®æ•µã«æ´¥æ³¢ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã™ã€‚

**æ•µã«ã¤ã„ã¦**
ã€€æ•µã«ã¯ğŸ”¥ã€ğŸ’§ã€â˜€ï¸ã€ğŸŒ±ã€ğŸ‘¿ã®5ç¨®é¡ãŒã„ã¾ã™ã€‚
ã€€æ•µã¯å€’ã™ã”ã¨ã«å¼·ããªã£ã¦è£œå……ã•ã‚Œã¾ã™ã€‚
ã€€ç‰¹å®šã®è¨ä¼æ•°ã«é”ã™ã‚‹ã¨ã€ã‚ˆã‚Šå¼·åŠ›ãªãƒœã‚¹æ•µï¼ˆğŸ‘¿ï¼‰ãŒå¼·åˆ¶çš„ã«å‡ºç¾ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

**ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼**
ã€€æ‰‹æœ­ãŒå…¨ã¦ãªããªã‚‹ã¨ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¨ãªã‚Šã¾ã™ã€‚
`;
        }

        // â˜…è¿½åŠ ï¼šè¨­å®šã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateStatusIndicators() {
            // æ—¢å­˜ã®è‰²ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            domElements.difficultyIndicator.className = 'w-4 h-4 rounded-full transition-colors';
            domElements.endlessModeIndicator.className = 'w-4 h-4 rounded-full transition-colors';

            // é›£æ˜“åº¦ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®è‰²ã‚’è¨­å®š
            switch (gameState.difficulty) {
                case 'easy':
                    domElements.difficultyIndicator.classList.add('bg-blue-600');
                    break;
                case 'normal':
                    domElements.difficultyIndicator.classList.add('bg-yellow-500');
                    break;
                case 'hard':
                    domElements.difficultyIndicator.classList.add('bg-red-600');
                    break;
            }

            // ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®è‰²ã‚’è¨­å®š
            if (gameState.isEndlessMode) {
                domElements.endlessModeIndicator.classList.add('bg-purple-600');
            } else {
                domElements.endlessModeIndicator.classList.add('bg-purple-800');
            }
        }


        // åˆæœŸåŒ–
        function initializeGame() {
            // ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰ãŒONãªã‚‰killTargetã‚’ç„¡é™ã«ã™ã‚‹
            if (gameState.isEndlessMode) {
                gameSettings.killTarget = Infinity;
            }

            // gameStateã‚’åˆæœŸåŒ–
            gameState.hand = [];
            gameState.board = [];
            gameState.selectedCardIndex = null;
            gameState.selectedSpecialCardIndex = null;
            gameState.killCount = 0;
            gameState.gameOver = false;
            gameState.handSelectionEnabled = true;
            gameState.playerLevel = 1;
            gameState.playerXp = 0;
            gameState.playerXpTotal = 0;
            gameState.expForNextLevel = 0;
            gameState.expAdded = 0;
            gameState.specialCardChargeCounter = 0;
            gameState.specialCardChargeAdd = 400;
            gameState.emptySlotsPreviousTurn = [];
            gameState.emptySlotsCurrentTurn = [];
            gameState.specialHand = [null, null];
            
            // é›£æ˜“åº¦è¨­å®šã‚’gameStateã«åæ˜ 
            gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesInitial];
            gameState.forcePurpleEnemyCount = gameSettings.bossThresholdInitial;
            gameState.forcePurpleEnemyThreshold = gameSettings.bossThresholdIncrement;
            gameState.isMidGameRatesActive = false;
            gameState.isFinalGameRatesActive = false;
            gameState.forcePurpleEnemy = false;
            gameState.bossExtraHpTimes = 0;

            // UIã‚’åˆæœŸåŒ–
            domElements.gameExplanation.textContent = generateExplanationText();
            updateMessageBoxUI('ã‚²ãƒ¼ãƒ é–‹å§‹');
            updateKillCountUI();
            updateStatusIndicators(); // â˜…ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°

            for (let i = 0; i < gameSettings.initialHandSize; i++) {
                drawCard();
            }

            // ãƒœãƒ¼ãƒ‰ã‚’ä¸€åº¦ã‚¯ãƒªã‚¢
            gameState.board = Array(gameSettings.boardSize).fill(null);
            for (let i = 0; i < gameSettings.boardSize; i++) {
                spawnEnemy(i);
            }

            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            domElements.boardSlots = document.querySelectorAll('#board-container .hex-cell');
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            if (!domElements.handContainer.listener) {
                domElements.handContainer.listener = handleHandClick;
                domElements.handContainer.addEventListener('click', domElements.handContainer.listener);
            }
            if (!domElements.boardContainer.listener) {
                domElements.boardContainer.listener = handleBoardClick;
                domElements.boardContainer.addEventListener('click', domElements.boardContainer.listener);
            }
            if (!domElements.specialHandContainer.listener) {
                domElements.specialHandContainer.listener = handleSpecialHandClick;
                domElements.specialHandContainer.addEventListener('click', domElements.specialHandContainer.listener);
            }


            // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®æ•µè£œå…… (å‰ã®ã‚¿ãƒ¼ãƒ³ã¯å­˜åœ¨ã—ãªã„ã®ã§ç©º)
            replenishEnemies();

            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            updateMessageBoxUI('æ‰‹æœ­ã‚’é¸æŠã—ã¦ãã ã•ã„');

            // åˆæœŸçŠ¶æ…‹ã®ç©ºã‚»ãƒ«ã‚’è¨˜éŒ² (æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ãŸã‚ã«)
            recordCurrentEmptySlots();
        }

        // æ•µã‚’è£œå……ã™ã‚‹é–¢æ•°
        function replenishEnemies() {
            gameState.emptySlotsPreviousTurn.forEach(emptySlotIndex => {
                if (!gameState.board[emptySlotIndex] || gameState.board[emptySlotIndex].empty) {
                    spawnEnemy(emptySlotIndex);
                }
            });
            gameState.emptySlotsPreviousTurn = []; // ãƒªã‚»ãƒƒãƒˆ
            updateBoardUI();
        }

        // ç¾åœ¨ã®ç©ºã‚»ãƒ«ã‚’è¨˜éŒ²ã™ã‚‹é–¢æ•°
        function recordCurrentEmptySlots() {
            gameState.emptySlotsCurrentTurn = gameState.board.reduce((acc, cell, index) => {
                if (!cell || cell.empty) {
                    acc.push(index);
                }
                return acc;
            }, []);
        }

        // ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã
        function drawCard() {
            if (gameState.hand.length < 5) {
                const randomCardType = gameSettings.cardTypes[Math.floor(Math.random() * gameSettings.cardTypes.length)];
                gameState.hand.push(randomCardType);
            }
        }

        // æ•µã‚’ç”Ÿæˆã™ã‚‹
        function spawnEnemy(slotIndex) {
            const enemyType = generateEnemyType();

            if (generateEnemyType != 'ğŸ‘¿'){
                gameState.bossExtraHpTimes = 0;
            } else {
                gameState.bossExtraHpTimes = 2;
            }
            const newHp = gameSettings.enemyHpValues[enemyType] + Math.floor(gameState.killCount / 5) * 3 + gameState.playerLevel * gameState.bossExtraHpTimes;
            gameState.board[slotIndex] = {
                enemy: {
                    type: enemyType,
                    hp: newHp,
                    maxHp: newHp
                },
                empty: false
            };
        }

        // æ‰‹æœ­ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleHandClick(event) {
            if (!gameState.handSelectionEnabled || gameState.gameOver) return;
            const cardElement = event.target.closest('.card');
            if (cardElement) {
                const cardIndex = parseInt(cardElement.dataset.cardIndex);
                if (gameState.hand[cardIndex] !== undefined) {
                    selectCard(cardIndex);
                }
            }
        }

        // ãƒœãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleBoardClick(event) {
            if (gameState.selectedCardIndex === null && gameState.selectedSpecialCardIndex === null || gameState.gameOver) return;
            const hexCell = event.target.closest('.hex-cell');
            if (hexCell) {
                const slotIndex = parseInt(hexCell.dataset.slotIndex);
                attack(slotIndex);
            }
        }

        // ç‰¹åˆ¥ãªæ‰‹æœ­ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handleSpecialHandClick(event) {
            if (gameState.gameOver) return;
            const cardElement = event.target.closest('.special-card');
            if (cardElement) {
                const cardIndex = parseInt(cardElement.dataset.specialCardIndex);
                if (gameState.specialHand[cardIndex]) {
                    selectCard(cardIndex + 5); // é€šå¸¸ã®æ‰‹æœ­é¸æŠã¨åŒã˜é–¢æ•°ã‚’ä½¿ç”¨
                }
            }
        }

        function updateHandUI() {
            domElements.handContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.cardIndex = i;

                if (gameState.hand[i] !== undefined) { 
                    card.textContent = gameState.hand[i];
                    if (gameState.handSelectionEnabled) {
                        card.classList.add('cursor-pointer');
                        card.classList.remove('opacity-50', 'cursor-not-allowed');
                    } else {
                        card.classList.add('opacity-50', 'cursor-not-allowed', 'cursor-default');
                    }
                    if (gameState.selectedCardIndex === i) {
                        card.classList.add('selected');
                    }
                } else {
                    card.classList.add('opacity-30', 'cursor-not-allowed');
                    card.textContent = '';
                }
                domElements.handContainer.appendChild(card);
            }
            domElements.handSlots = document.querySelectorAll('#hand-container .card');
            updateCardDescriptionUI();
        }

        function updateSpecialHandUI() {
            domElements.specialHandSlots = document.querySelectorAll('#special-hand-container .special-card');

            for (let i = 0; i < 2; i++) {
                const card = domElements.specialHandSlots[i];
                card.classList.remove('selected', 'opacity-30', 'cursor-not-allowed', 'cursor-pointer'); 

                if (gameState.specialHand[i]) { 
                    card.textContent = gameState.specialHand[i];
                    card.classList.add('cursor-pointer'); 
                } else {
                    card.classList.add('opacity-30', 'cursor-not-allowed'); 
                    card.textContent = '';
                }

                if (gameState.selectedSpecialCardIndex === i) {
                    card.classList.add('selected');
                }
            }
            updateCardDescriptionUI();
        }

        // ãƒœãƒ¼ãƒ‰ã®è¡¨ç¤ºã‚’æ›´æ–°
        function updateBoardUI() {
            domElements.boardContainer.querySelectorAll('.hex-cell').forEach((cell) => {
                const slotIndex = parseInt(cell.dataset.slotIndex);
                const cellInner = cell.querySelector('.hex-inner');
                cellInner.className = 'hex-inner';

                if (gameState.board[slotIndex] && !gameState.board[slotIndex].empty) {
                    const enemy = gameState.board[slotIndex].enemy;
                    cellInner.textContent = enemy.type;
                    cellInner.innerHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%; background-color: ${enemy.hp <= enemy.maxHp / 2 ? 'red' : enemy.hp <= enemy.maxHp * 0.75 ? 'yellow' : 'green'};"></div><span class="hp-text">${enemy.hp}</span></div>`;
                    switch (enemy.type) {
                        case 'ğŸ”¥': cellInner.classList.add('bg-red-500'); break;
                        case 'ğŸ’§': cellInner.classList.add('bg-blue-500'); break;
                        case 'â˜€ï¸': cellInner.classList.add('bg-yellow-500'); break;
                        case 'ğŸŒ±': cellInner.classList.add('bg-green-500'); break;
                        case 'ğŸ‘¿': cellInner.classList.add('bg-purple-500'); break;
                    }
                } else {
                    cellInner.classList.add('bg-gray-400');
                    cellInner.textContent = 'Empty';
                }
            });
        }

        // å€’ã—ãŸæ•µã®æ•°ã‚’æ›´æ–°
        function updateKillCountUI() {
            const expBarWidth = (gameState.expForNextLevel / gameSettings.levelUpThreshold) * 100;
            const expBar = `<div style="width: 100%; background-color: #4b5563; border-radius: 0.25rem; margin-top: 0.25rem; position: relative; height: 0.6rem;">` +
                           `<div style="width: ${expBarWidth}%; background-color: #86ef7d; height: 100%; border-radius: 0.25rem;"></div></div>`;
            
            const targetDisplay = gameSettings.killTarget === Infinity ? 'âˆ' : gameSettings.killTarget;

            domElements.killCountDisplay.innerHTML = `å€’ã—ãŸæ•µã®æ•°: ${gameState.killCount}/${targetDisplay}<br>Lv: ${gameState.playerLevel}<br>Exp: ${gameState.playerXpTotal}  (+${gameState.expAdded})${expBar}`;
        }

        // ã‚«ãƒ¼ãƒ‰ã®èª¬æ˜ã‚’æ›´æ–°
        function updateCardDescriptionUI() {
            let description = 'é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã‚’è¡¨ç¤º';
            let damageText = '';

            if (gameState.selectedCardIndex !== null) {
                const cardType = gameState.hand[gameState.selectedCardIndex];
                description = gameSettings.cardDescriptions[cardType] || description;
                const baseDamage = gameSettings.baseDamage[cardType] || 0;
                damageText = `<span class="damage-text">åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸: ${baseDamage + gameState.playerLevel}</span>`;
            } else if (gameState.selectedSpecialCardIndex !== null) {
                const cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                description = gameSettings.specialCardDescriptions[cardType] || description;
                const baseDamage = gameSettings.specialCardBaseDamage[cardType] || 0;
                damageText = `<span class="damage-text">åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸: ${baseDamage + gameState.playerLevel}</span>`;
            } else {
                damageText = '';
            }

            domElements.cardDescription.innerHTML = `${description}<br>${damageText}`;
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã®æ›´æ–°
        function updateMessageBoxUI(message) {
            domElements.messageBox.textContent = message;
        }

        // ã‚«ãƒ¼ãƒ‰ã®é¸æŠ
        function selectCard(index) {
            if (gameState.gameOver || !gameState.handSelectionEnabled) return;

            if (index >= 0 && index < 5) {
                gameState.selectedCardIndex = index;
                gameState.selectedSpecialCardIndex = null;
            } else {
                gameState.selectedSpecialCardIndex = index - 5; 
                gameState.selectedCardIndex = null;
            }

            updateHandUI();
            updateSpecialHandUI();
            updateCardDescriptionUI();
            updateMessageBoxUI('æ”»æ’ƒã™ã‚‹ãƒã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„');
        }

        // æ”»æ’ƒ
        function attack(slotIndex) {
            if (gameState.gameOver) return;

            let cardType = null;
            let baseDamage = 0;
            let selectedIndex = null;

            if (gameState.selectedCardIndex !== null) {
                cardType = gameState.hand[gameState.selectedCardIndex];
                baseDamage = gameSettings.baseDamage[cardType] + gameState.playerLevel;
                selectedIndex = gameState.selectedCardIndex;
                
            } else if (gameState.selectedSpecialCardIndex !== null) {
                cardType = gameState.specialHand[gameState.selectedSpecialCardIndex];
                baseDamage = gameSettings.specialCardBaseDamage[cardType] + gameState.playerLevel;
                selectedIndex = gameState.selectedSpecialCardIndex;
                
            } else {
                updateMessageBoxUI('æ‰‹æœ­ã‚’å…ˆã«é¸ã‚“ã§ãã ã•ã„');
                return;
            }

            if (!gameState.board[slotIndex] || gameState.board[slotIndex].empty) {
                updateMessageBoxUI('ç©ºã®ãƒã‚¹ã«ã¯æ”»æ’ƒã§ãã¾ã›ã‚“');
                return;
            }

            let enemiesKilled = 0;
            const attackedSlot = gameState.board[slotIndex];
            let damage = baseDamage;

            switch (cardType) {
                case 'âš¡ï¸': {
                        const queue = [slotIndex];
                        const damagedSlots = new Set();
                        damagedSlots.add(slotIndex);
                        attackedSlot.enemy.hp -= damage;
                        if (attackedSlot.enemy.hp <= 0) {
                            attackedSlot.empty = true;
                            enemiesKilled++;
                            handleBossSpawn();
                        }

                        while (queue.length > 0) {
                            const currentSlotIndex = queue.shift();
                            const adjacentSlots = gameSettings.adjacentSlots[currentSlotIndex] || [];
                            for (const adjacentSlotIndex of adjacentSlots) {
                                if (gameState.board[adjacentSlotIndex] && !damagedSlots.has(adjacentSlotIndex) && !gameState.board[adjacentSlotIndex].empty && gameState.board[adjacentSlotIndex].enemy.type === attackedSlot.enemy.type) {
                                    damagedSlots.add(adjacentSlotIndex);
                                    const chainDamage = Math.floor(damage * gameSettings.chainDamageMultiplier);
                                    gameState.board[adjacentSlotIndex].enemy.hp -= chainDamage;
                                    if (gameState.board[adjacentSlotIndex].enemy.hp <= 0) {
                                        gameState.board[adjacentSlotIndex].empty = true;
                                        enemiesKilled++;
                                        handleBossSpawn();
                                    }
                                    queue.push(adjacentSlotIndex);
                                }
                            }
                        }

                    break;
                }
                case 'ğŸ—¡ï¸': {
                    damage += Math.floor(attackedSlot.enemy.maxHp / 5);
                    break;
                }
                case 'ğŸ’¥': {
                        const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                        const adjacentEnemies = adjacentSlots.filter(index => gameState.board[index] && !gameState.board[index].empty);
                        const splashDamage = adjacentEnemies.length > 0 ? Math.floor((damage * gameSettings.splashDamageMultiplier) / adjacentEnemies.length) : 0;
                        adjacentEnemies.forEach(adjacentSlotIndex => {
                            gameState.board[adjacentSlotIndex].enemy.hp -= splashDamage;
                            if (gameState.board[adjacentSlotIndex].enemy.hp <= 0) {
                                gameState.board[adjacentSlotIndex].empty = true;
                                enemiesKilled++;
                                handleBossSpawn();
                            }
                        });
                    break;
                }
                case 'ğŸ’€': {
                        const targetEnemyType = attackedSlot.enemy.type;
                        gameState.board.forEach(cell => {
                            if (cell && !cell.empty && cell.enemy.type === targetEnemyType) {
                                cell.enemy.hp -= baseDamage;
                                if (cell.enemy.hp <= 0) {
                                    cell.empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                    break;
                }
                case 'ğŸ¦ ': {
                        const targetEnemyType = attackedSlot.enemy.type;
                        const adjacentSlots = gameSettings.adjacentSlots[slotIndex] || [];
                        adjacentSlots.forEach(adjIndex => {
                            if (gameState.board[adjIndex] && !gameState.board[adjIndex].empty) {
                                gameState.board[adjIndex].enemy.type = targetEnemyType;
                                gameState.board[adjIndex].enemy.hp -= Math.floor(baseDamage * 0.3);
                                if (gameState.board[adjIndex].enemy.hp <= 0) {
                                    gameState.board[adjIndex].empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                        attackedSlot.enemy.hp -= baseDamage;
                        if (attackedSlot.enemy.hp <= 0) {
                            attackedSlot.empty = true;
                            enemiesKilled++;
                            handleBossSpawn();
                        }
                    break;
                }
                case 'ğŸŒŠ': {
                        gameState.board.forEach(cell => {
                            if (cell && !cell.empty) {
                                cell.enemy.hp -= baseDamage;
                                if (cell.enemy.hp <= 0) {
                                    cell.empty = true;
                                    enemiesKilled++;
                                    handleBossSpawn();
                                }
                            }
                        });
                    break;
                }
            }

            if (cardType !== 'âš¡ï¸' && cardType !== 'ğŸ’€' && cardType !== 'ğŸŒŠ') {
                attackedSlot.enemy.hp -= damage;
                if (attackedSlot.enemy.hp <= 0) {
                    attackedSlot.empty = true;
                    enemiesKilled++;
                    handleBossSpawn();
                }
            }

            updateMessageBoxUI('æ”»æ’ƒï¼');

            if (selectedIndex !== null) {
                if (gameState.selectedCardIndex !== null) {
                    gameState.hand[gameState.selectedCardIndex] = undefined;
                    gameState.hand = gameState.hand.filter(card => card !== undefined);
                } else if (gameState.selectedSpecialCardIndex !== null) {
                    gameState.specialHand[gameState.selectedSpecialCardIndex] = null;
                }
            }

            gameState.selectedCardIndex = null;
            gameState.selectedSpecialCardIndex = null;
            gameState.handSelectionEnabled = false;

            domElements.handSlots.forEach(card => {
                if (!card.classList.contains('opacity-30')) {
                    card.classList.add('disabled');
                }
            });
            domElements.specialHandSlots.forEach(card => {
                if (!card.classList.contains('opacity-30')) {
                    card.classList.add('disabled');
                }
            });

            gameState.killCount += enemiesKilled;
            updateHandUI();
            updateSpecialHandUI();
            updateBoardUI();
            handleExperience(enemiesKilled);
            updateKillCountUI();

            setTimeout(() => {

                const cardsToDraw = Math.min(enemiesKilled, 5 - gameState.hand.length);
                for (let i = 0; i < cardsToDraw; i++) {
                    drawCard();
                }

                recordCurrentEmptySlots();

                const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);

                if (isBoardCompletelyEmpty) {
                    gameState.emptySlotsPreviousTurn = Array.from({ length: gameSettings.boardSize }, (_, i) => i);
                    replenishEnemies();
                    gameState.emptySlotsCurrentTurn = [];
                } else {
                    replenishEnemies();
                    gameState.emptySlotsPreviousTurn = [...gameState.emptySlotsCurrentTurn];
                    gameState.emptySlotsCurrentTurn = [];
                }

                gameState.handSelectionEnabled = true;

                domElements.handSlots.forEach(card => {
                    card.classList.remove('disabled');
                });
                domElements.specialHandSlots.forEach(card => {
                    card.classList.remove('disabled');
                });

                updateHandUI();
                updateSpecialHandUI();
                updateBoardUI();

                updateMessageBoxUI('æ‰‹æœ­ã‚’é¸æŠã—ã¦ãã ã•ã„');
                
                if (gameState.killCount >= gameSettings.killTarget) {
                    gameState.gameOver = true;
                    updateMessageBoxUI('ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼');
                    domElements.messageBox.classList.add('message-box-clear');
                    endGame();
                }

                if (gameState.hand.length === 0 && gameState.specialHand.every(card => card === null) && gameState.board.some(cell => cell && !cell.empty)) {
                    gameState.gameOver = true;
                    updateMessageBoxUI('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼šæ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“');
                    domElements.messageBox.classList.add('message-box-gameover');
                    endGame();
                    return;
                }

            }, 400);

            gameState.handSelectionEnabled = true;
        }


        // ãƒœã‚¹å‡ºç¾ã®åˆ¤å®š
        function handleBossSpawn() {
            if (gameState.killCount >= gameState.forcePurpleEnemyCount) {
                gameState.forcePurpleEnemy = true;
                gameState.forcePurpleEnemyCount += gameState.forcePurpleEnemyThreshold;
            }
        }

        // æ•µã®ç¨®é¡ã®ç”Ÿæˆ
        function generateEnemyType() {
            if (gameState.forcePurpleEnemy) {
                gameState.forcePurpleEnemy = false;
                return 'ğŸ‘¿';
            } else {
                let rand = Math.random();
                let cumulativeProbability = 0;
                for (let i = 0; i < gameState.enemySpawnRates.length; i++) {
                    cumulativeProbability += gameState.enemySpawnRates[i];
                    if (rand < cumulativeProbability) {
                        return gameSettings.enemyTypes[i];
                    }
                }
                return gameSettings.enemyTypes[gameSettings.enemyTypes.length - 1];
            }
        }

        // çµŒé¨“å€¤ã®å‡¦ç†
        function handleExperience(enemiesKilled) {
            const isBoardCompletelyEmpty = gameState.board.every(cell => !cell || cell.empty);

            if (isBoardCompletelyEmpty) {
                // å…¨æ»…æ™‚ã¯å›ºå®šãƒœãƒ¼ãƒŠã‚¹
                gameState.expAdded = gameSettings.specialCardChargeThreshold;
            } else {
                // é€šå¸¸æ™‚ã¯è¨ˆç®—
                gameState.expAdded = (enemiesKilled * gameSettings.experiencePerKill) + (enemiesKilled > 0 ? (enemiesKilled - 1) * gameSettings.experienceChainBonus : 0);
            }
            
            gameState.playerXpTotal += gameState.expAdded;
            gameState.playerXp += gameState.expAdded;
            gameState.specialCardChargeCounter += gameState.expAdded;

            if (gameState.killCount >= gameSettings.midGameRatesCount && !gameState.isMidGameRatesActive) {
                gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesMidGame];
                gameState.isMidGameRatesActive = true;
            } else if (gameState.killCount >= gameSettings.finalGameRatesCount && !gameState.isFinalGameRatesActive) {
                gameState.enemySpawnRates = [...gameSettings.enemySpawnRatesFinalGame];
                gameState.isFinalGameRatesActive = true;
            }

            while (gameState.playerXp >= gameSettings.levelUpThreshold) {
                gameState.playerLevel++;
                gameState.playerXp -= gameSettings.levelUpThreshold;
            }

            gameState.expForNextLevel = gameState.playerXp % gameSettings.levelUpThreshold;

            while (gameState.specialCardChargeCounter >= gameState.specialCardChargeAdd) {
                gameState.specialCardChargeAdd += gameSettings.specialCardChargeThreshold;
                addSpecialCardToHand();
                updateSpecialHandUI();
            }
        }

        function addSpecialCardToHand() {
            const emptySlotIndex = gameState.specialHand.findIndex(card => card === null);
            if (emptySlotIndex !== -1) {
                const randomCardType = gameSettings.specialCardTypes[Math.floor(Math.random() * gameSettings.specialCardTypes.length)];
                gameState.specialHand[emptySlotIndex] = randomCardType;
            }
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†
        function endGame() {
            domElements.handContainer.classList.add('disabled-overlay');
            domElements.boardContainer.classList.add('disabled-overlay');
            domElements.specialHandContainer.classList.add('disabled-overlay');
        }
        
        // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆå‡¦ç†
        function resetGame() {
            domElements.handContainer.classList.remove('disabled-overlay');
            domElements.boardContainer.classList.remove('disabled-overlay');
            domElements.specialHandContainer.classList.remove('disabled-overlay');
            domElements.messageBox.classList.remove('message-box-clear', 'message-box-gameover');

            // ç¾åœ¨ã®é›£æ˜“åº¦è¨­å®šã‚’å†é©ç”¨
            applyDifficultySettings(gameState.difficulty);
            initializeGame();
        }

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        document.getElementById('reset-button').addEventListener('click', resetGame);
        
        // â–¼â–¼â–¼ è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯ â–¼â–¼â–¼
        const settingsModal = document.getElementById('settings-modal');
        const openSettingsButton = document.getElementById('settings-button');
        const cancelButton = document.getElementById('cancel-button');
        const confirmButton = document.getElementById('confirm-button');
        const modalOverlay = document.getElementById('modal-overlay');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        const endlessModeButton = document.getElementById('endless-mode-button');

        let tempDifficulty;
        let tempIsEndlessMode;

        function updateDifficultyButtonsUI() {
            difficultyButtons.forEach(button => {
                if (button.dataset.difficulty === tempDifficulty) {
                    button.classList.add('scale-110');
                    button.classList.remove('scale-90', 'opacity-75');
                } else {
                    button.classList.add('scale-90', 'opacity-75');
                    button.classList.remove('scale-110');
                }
            });
        }

        function updateEndlessModeButtonUI() {
            if (tempIsEndlessMode) {
                endlessModeButton.textContent = 'ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰: ON';
                endlessModeButton.classList.replace('bg-purple-800', 'bg-purple-600');
            } else {
                endlessModeButton.textContent = 'ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ãƒ¢ãƒ¼ãƒ‰: OFF';
                endlessModeButton.classList.replace('bg-purple-600', 'bg-purple-800');
            }
        }

        function openModal() {
            tempDifficulty = gameState.difficulty;
            tempIsEndlessMode = gameState.isEndlessMode;
            updateDifficultyButtonsUI();
            updateEndlessModeButtonUI();
            settingsModal.classList.remove('hidden');
        }

        function closeModal() {
            settingsModal.classList.add('hidden');
        }

        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                tempDifficulty = button.dataset.difficulty;
                updateDifficultyButtonsUI();
            });
        });

        endlessModeButton.addEventListener('click', () => {
            tempIsEndlessMode = !tempIsEndlessMode;
            updateEndlessModeButtonUI();
        });

        openSettingsButton.addEventListener('click', openModal);
        cancelButton.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', closeModal);

        confirmButton.addEventListener('click', () => {
            const difficultyChanged = gameState.difficulty !== tempDifficulty;
            const endlessModeChanged = gameState.isEndlessMode !== tempIsEndlessMode;

            if (difficultyChanged || endlessModeChanged) {
                gameState.difficulty = tempDifficulty;
                gameState.isEndlessMode = tempIsEndlessMode;
                applyDifficultySettings(gameState.difficulty);
                resetGame();
            }
            closeModal();
        });
        
        // â–¼â–¼â–¼ ã‚²ãƒ¼ãƒ ã®åˆå›é–‹å§‹å‡¦ç† â–¼â–¼â–¼
        applyDifficultySettings(gameState.difficulty);
        initializeGame();
        
    </script>
</body>
</html>
